{"ast":null,"code":"'use client';\n\nimport _objectSpread from \"/Users/macbook/developer/2025/2026/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { isMultiTouchEvent, getEventPoint, addPointerEvent } from '@chakra-ui/utils';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass PanEvent {\n  constructor(event, handlers, threshold) {\n    var _event$view;\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []);\n    // The pointer event that started the pan session\n    __publicField(this, \"startEvent\", null);\n    // The current pointer event for the pan session\n    __publicField(this, \"lastEvent\", null);\n    // The current pointer event info for the pan session\n    __publicField(this, \"lastEventInfo\", null);\n    __publicField(this, \"handlers\", {});\n    __publicField(this, \"removeListeners\", () => {});\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n    __publicField(this, \"threshold\", 3);\n    __publicField(this, \"win\");\n    __publicField(this, \"updatePoint\", () => {\n      if (!(this.lastEvent && this.lastEventInfo)) return;\n      const info = getPanInfo(this.lastEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        timestamp\n      } = getFrameData();\n      this.history.push(_objectSpread(_objectSpread({}, info.point), {}, {\n        timestamp\n      }));\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart === null || onStart === void 0 || onStart(this.lastEvent, info);\n        this.startEvent = this.lastEvent;\n      }\n      onMove === null || onMove === void 0 || onMove(this.lastEvent, info);\n    });\n    __publicField(this, \"onPointerMove\", (event, info) => {\n      this.lastEvent = event;\n      this.lastEventInfo = info;\n      sync.update(this.updatePoint, true);\n    });\n    __publicField(this, \"onPointerUp\", (event, info) => {\n      const panInfo = getPanInfo(info, this.history);\n      const {\n        onEnd,\n        onSessionEnd\n      } = this.handlers;\n      onSessionEnd === null || onSessionEnd === void 0 || onSessionEnd(event, panInfo);\n      this.end();\n      if (!onEnd || !this.startEvent) return;\n      onEnd === null || onEnd === void 0 || onEnd(event, panInfo);\n    });\n    this.win = (_event$view = event.view) !== null && _event$view !== void 0 ? _event$view : window;\n    if (isMultiTouchEvent(event)) return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    const info = {\n      point: getEventPoint(event)\n    };\n    const {\n      timestamp\n    } = getFrameData();\n    this.history = [_objectSpread(_objectSpread({}, info.point), {}, {\n      timestamp\n    })];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart === null || onSessionStart === void 0 || onSessionStart(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe(addPointerEvent(this.win, \"pointermove\", this.onPointerMove), addPointerEvent(this.win, \"pointerup\", this.onPointerUp), addPointerEvent(this.win, \"pointercancel\", this.onPointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    var _this$removeListeners;\n    (_this$removeListeners = this.removeListeners) === null || _this$removeListeners === void 0 || _this$removeListeners.call(this);\n    cancelSync.update(this.updatePoint);\n  }\n}\nfunction subtract(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nconst toMilliseconds = v => v * 1e3;\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return v => fns.reduce((a, b) => b(a), v);\n}\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n  return 0;\n}\nexport { PanEvent, distance };","map":{"version":3,"names":["_objectSpread","isMultiTouchEvent","getEventPoint","addPointerEvent","sync","getFrameData","cancelSync","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","PanEvent","constructor","event","handlers","threshold","_event$view","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","distance","offset","x","y","timestamp","push","point","onStart","onMove","update","updatePoint","panInfo","onEnd","onSessionEnd","end","win","view","window","stopPropagation","preventDefault","onSessionStart","removeListeners","pipe","onPointerMove","onPointerUp","updateHandlers","_this$removeListeners","call","subtract","a","b","delta","length","velocity","getVelocity","toMilliseconds","v","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","_len","arguments","fns","Array","_key","reduce","distance1D","Math","abs","isPoint","xDelta","yDelta","sqrt"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@chakra-ui/hooks/dist/esm/use-pan-event/pan-event.mjs"],"sourcesContent":["'use client';\nimport { isMultiTouchEvent, getEventPoint, addPointerEvent } from '@chakra-ui/utils';\nimport sync, { getFrameData, cancelSync } from 'framesync';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass PanEvent {\n  constructor(event, handlers, threshold) {\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []);\n    // The pointer event that started the pan session\n    __publicField(this, \"startEvent\", null);\n    // The current pointer event for the pan session\n    __publicField(this, \"lastEvent\", null);\n    // The current pointer event info for the pan session\n    __publicField(this, \"lastEventInfo\", null);\n    __publicField(this, \"handlers\", {});\n    __publicField(this, \"removeListeners\", () => {\n    });\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n    __publicField(this, \"threshold\", 3);\n    __publicField(this, \"win\");\n    __publicField(this, \"updatePoint\", () => {\n      if (!(this.lastEvent && this.lastEventInfo))\n        return;\n      const info = getPanInfo(this.lastEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold)\n        return;\n      const { timestamp } = getFrameData();\n      this.history.push({ ...info.point, timestamp });\n      const { onStart, onMove } = this.handlers;\n      if (!isPanStarted) {\n        onStart?.(this.lastEvent, info);\n        this.startEvent = this.lastEvent;\n      }\n      onMove?.(this.lastEvent, info);\n    });\n    __publicField(this, \"onPointerMove\", (event, info) => {\n      this.lastEvent = event;\n      this.lastEventInfo = info;\n      sync.update(this.updatePoint, true);\n    });\n    __publicField(this, \"onPointerUp\", (event, info) => {\n      const panInfo = getPanInfo(info, this.history);\n      const { onEnd, onSessionEnd } = this.handlers;\n      onSessionEnd?.(event, panInfo);\n      this.end();\n      if (!onEnd || !this.startEvent)\n        return;\n      onEnd?.(event, panInfo);\n    });\n    this.win = event.view ?? window;\n    if (isMultiTouchEvent(event))\n      return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    const info = { point: getEventPoint(event) };\n    const { timestamp } = getFrameData();\n    this.history = [{ ...info.point, timestamp }];\n    const { onSessionStart } = handlers;\n    onSessionStart?.(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe(\n      addPointerEvent(this.win, \"pointermove\", this.onPointerMove),\n      addPointerEvent(this.win, \"pointerup\", this.onPointerUp),\n      addPointerEvent(this.win, \"pointercancel\", this.onPointerUp)\n    );\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    this.removeListeners?.();\n    cancelSync.update(this.updatePoint);\n  }\n}\nfunction subtract(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nconst toMilliseconds = (v) => v * 1e3;\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return { x: 0, y: 0 };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return { x: 0, y: 0 };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction pipe(...fns) {\n  return (v) => fns.reduce((a, b) => b(a), v);\n}\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n  return 0;\n}\n\nexport { PanEvent, distance };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}