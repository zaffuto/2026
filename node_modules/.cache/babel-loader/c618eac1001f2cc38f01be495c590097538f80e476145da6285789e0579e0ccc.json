{"ast":null,"code":"\"use strict\";\n\nimport { esc } from './esc.js';\nconst expandTokenReferences = (str, resolve) => {\n  let expanded = \"\";\n  let index = 0;\n  let state = \"char\";\n  let tokenPath = \"\";\n  let fallback = \"\";\n  const currentStates = [];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"{\") {\n      const endIndex = str.indexOf(\"}\", index);\n      if (endIndex === -1) {\n        break;\n      }\n      const path = str.slice(index + 1, endIndex);\n      const resolved = resolve(path);\n      expanded += resolved ?? path;\n      index = endIndex + 1;\n      continue;\n    }\n    if (state === \"token\") {\n      if (char === \",\") {\n        if (str[index] === \"\") {\n          index++;\n        }\n        state = \"fallback\";\n        currentStates.push(state);\n        const resolved = resolve(tokenPath);\n        if (resolved?.endsWith(\")\")) {\n          expanded += resolved.slice(0, -1);\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"fallback\") {\n      const nextFallback = fallback + char;\n      if (nextFallback === \", var(\") {\n        const innerEndIndex = cssVarParser(str.slice(index + 1));\n        const endIndex = innerEndIndex + index + 1;\n        const cssVar = str.slice(index + 1, endIndex);\n        if (endIndex === -1) {\n          break;\n        }\n        expanded += \", var(\" + cssVar + \")\";\n        index = endIndex + 1;\n        state = currentStates.pop() ?? state;\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"token\" || state === \"fallback\") {\n      index++;\n      if (char === \")\") {\n        state = currentStates.pop() ?? state ?? \"char\";\n        fallback += char;\n        const resolved = tokenPath ? resolve(tokenPath) ?? esc(tokenPath) : tokenPath;\n        if (fallback) {\n          fallback = fallback.slice(1).trim();\n          if (!fallback.startsWith(\"token(\") && fallback.endsWith(\")\")) {\n            fallback = fallback.slice(0, -1);\n          }\n          if (fallback.includes(\"token(\")) {\n            const parsed = expandTokenReferences(fallback, resolve);\n            if (parsed) {\n              fallback = parsed.slice(0, -1);\n            }\n          } else if (fallback) {\n            const resolvedFallback = resolve(fallback);\n            if (resolvedFallback) {\n              fallback = resolvedFallback;\n            }\n          }\n        }\n        const lastChar = expanded.at(-1);\n        if (fallback) {\n          if (lastChar?.trim()) {\n            expanded += resolved.slice(0, -1) + (\", \" + fallback + \")\");\n          } else {\n            expanded += fallback;\n          }\n        } else {\n          expanded += resolved || \")\";\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        state = \"char\";\n        continue;\n      }\n      if (state === \"token\") {\n        tokenPath += char;\n      }\n      if (state === \"fallback\") {\n        fallback += char;\n      }\n      continue;\n    }\n    const tokenIndex = str.indexOf(\"token(\", index);\n    if (tokenIndex !== -1) {\n      const innerTokenIndex = tokenIndex + \"token(\".length;\n      expanded += str.slice(index, tokenIndex);\n      index = innerTokenIndex;\n      state = \"token\";\n      currentStates.push(state);\n      continue;\n    }\n    expanded += char;\n    index++;\n  }\n  return expanded;\n};\nconst cssVarParser = str => {\n  let index = 0;\n  const openedParenthesises = [\"(\"];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"(\") {\n      openedParenthesises.push(char);\n    } else if (char === \")\") {\n      openedParenthesises.pop();\n      if (openedParenthesises.length === 0) {\n        return index;\n      }\n    }\n    index++;\n  }\n  return index;\n};\nexport { expandTokenReferences };","map":{"version":3,"names":["esc","expandTokenReferences","str","resolve","expanded","index","state","tokenPath","fallback","currentStates","length","char","endIndex","indexOf","path","slice","resolved","push","endsWith","nextFallback","innerEndIndex","cssVarParser","cssVar","pop","trim","startsWith","includes","parsed","resolvedFallback","lastChar","at","tokenIndex","innerTokenIndex","openedParenthesises"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@chakra-ui/react/dist/esm/styled-system/expand-reference.js"],"sourcesContent":["\"use strict\";\nimport { esc } from './esc.js';\n\nconst expandTokenReferences = (str, resolve) => {\n  let expanded = \"\";\n  let index = 0;\n  let state = \"char\";\n  let tokenPath = \"\";\n  let fallback = \"\";\n  const currentStates = [];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"{\") {\n      const endIndex = str.indexOf(\"}\", index);\n      if (endIndex === -1) {\n        break;\n      }\n      const path = str.slice(index + 1, endIndex);\n      const resolved = resolve(path);\n      expanded += resolved ?? path;\n      index = endIndex + 1;\n      continue;\n    }\n    if (state === \"token\") {\n      if (char === \",\") {\n        if (str[index] === \"\") {\n          index++;\n        }\n        state = \"fallback\";\n        currentStates.push(state);\n        const resolved = resolve(tokenPath);\n        if (resolved?.endsWith(\")\")) {\n          expanded += resolved.slice(0, -1);\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"fallback\") {\n      const nextFallback = fallback + char;\n      if (nextFallback === \", var(\") {\n        const innerEndIndex = cssVarParser(str.slice(index + 1));\n        const endIndex = innerEndIndex + index + 1;\n        const cssVar = str.slice(index + 1, endIndex);\n        if (endIndex === -1) {\n          break;\n        }\n        expanded += \", var(\" + cssVar + \")\";\n        index = endIndex + 1;\n        state = currentStates.pop() ?? state;\n        fallback = \"\";\n        continue;\n      }\n    }\n    if (state === \"token\" || state === \"fallback\") {\n      index++;\n      if (char === \")\") {\n        state = currentStates.pop() ?? state ?? \"char\";\n        fallback += char;\n        const resolved = tokenPath ? resolve(tokenPath) ?? esc(tokenPath) : tokenPath;\n        if (fallback) {\n          fallback = fallback.slice(1).trim();\n          if (!fallback.startsWith(\"token(\") && fallback.endsWith(\")\")) {\n            fallback = fallback.slice(0, -1);\n          }\n          if (fallback.includes(\"token(\")) {\n            const parsed = expandTokenReferences(fallback, resolve);\n            if (parsed) {\n              fallback = parsed.slice(0, -1);\n            }\n          } else if (fallback) {\n            const resolvedFallback = resolve(fallback);\n            if (resolvedFallback) {\n              fallback = resolvedFallback;\n            }\n          }\n        }\n        const lastChar = expanded.at(-1);\n        if (fallback) {\n          if (lastChar?.trim()) {\n            expanded += resolved.slice(0, -1) + (\", \" + fallback + \")\");\n          } else {\n            expanded += fallback;\n          }\n        } else {\n          expanded += resolved || \")\";\n        }\n        tokenPath = \"\";\n        fallback = \"\";\n        state = \"char\";\n        continue;\n      }\n      if (state === \"token\") {\n        tokenPath += char;\n      }\n      if (state === \"fallback\") {\n        fallback += char;\n      }\n      continue;\n    }\n    const tokenIndex = str.indexOf(\"token(\", index);\n    if (tokenIndex !== -1) {\n      const innerTokenIndex = tokenIndex + \"token(\".length;\n      expanded += str.slice(index, tokenIndex);\n      index = innerTokenIndex;\n      state = \"token\";\n      currentStates.push(state);\n      continue;\n    }\n    expanded += char;\n    index++;\n  }\n  return expanded;\n};\nconst cssVarParser = (str) => {\n  let index = 0;\n  const openedParenthesises = [\"(\"];\n  while (index < str.length) {\n    const char = str[index];\n    if (char === \"(\") {\n      openedParenthesises.push(char);\n    } else if (char === \")\") {\n      openedParenthesises.pop();\n      if (openedParenthesises.length === 0) {\n        return index;\n      }\n    }\n    index++;\n  }\n  return index;\n};\n\nexport { expandTokenReferences };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}