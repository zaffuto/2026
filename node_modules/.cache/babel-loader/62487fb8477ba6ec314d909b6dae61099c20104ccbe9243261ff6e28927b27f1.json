{"ast":null,"code":"\"use strict\";\n\nimport { getReferences } from './references.js';\nconst addCssVariables = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/css-var\",\n  transform(token, dictionary) {\n    const {\n      prefix,\n      formatCssVar\n    } = dictionary;\n    const {\n      negative,\n      originalPath\n    } = token.extensions;\n    const path = negative ? originalPath : token.path;\n    return {\n      cssVar: formatCssVar(path.filter(Boolean), prefix)\n    };\n  }\n};\nconst addConditionalCssVariables = {\n  enforce: \"post\",\n  type: \"value\",\n  name: \"tokens/conditionals\",\n  transform(token, dictionary) {\n    const {\n      prefix,\n      formatCssVar\n    } = dictionary;\n    const refs = getReferences(token.value);\n    if (!refs.length) return token.value;\n    refs.forEach(ref => {\n      const variable = formatCssVar(ref.split(\".\"), prefix);\n      token.value = token.value.replace(`{${variable.ref}}`, variable);\n    });\n    return token.value;\n  }\n};\nconst addColorPalette = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/colors/colorPalette\",\n  match(token) {\n    return token.extensions.category === \"colors\" && !token.extensions.virtual;\n  },\n  transform(token, dict) {\n    let path = token.path.slice();\n    path.pop();\n    path.shift();\n    if (path.length === 0) {\n      const newPath = [...token.path];\n      newPath.shift();\n      path = newPath;\n    }\n    if (path.length === 0) {\n      return {};\n    }\n    const roots = path.reduce((acc, _, i, arr) => {\n      const next = arr.slice(0, i + 1);\n      acc.push(next);\n      return acc;\n    }, []);\n    const root = path[0];\n    const value = dict.formatTokenName(path);\n    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {\n      acc.push(arr.slice(i));\n      return acc;\n    }, []);\n    if (keys.length === 0) {\n      keys.push([\"\"]);\n    }\n    return {\n      colorPalette: {\n        value,\n        roots,\n        keys\n      }\n    };\n  }\n};\nconst tokenTransforms = [addCssVariables, addConditionalCssVariables, addColorPalette];\nexport { addColorPalette, addConditionalCssVariables, addCssVariables, tokenTransforms };","map":{"version":3,"names":["getReferences","addCssVariables","type","enforce","name","transform","token","dictionary","prefix","formatCssVar","negative","originalPath","extensions","path","cssVar","filter","Boolean","addConditionalCssVariables","refs","value","length","forEach","ref","variable","split","replace","addColorPalette","match","category","virtual","dict","slice","pop","shift","newPath","roots","reduce","acc","_","i","arr","next","push","root","formatTokenName","keys","indexOf","colorPalette","tokenTransforms"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@chakra-ui/react/dist/esm/styled-system/token-transforms.js"],"sourcesContent":["\"use strict\";\nimport { getReferences } from './references.js';\n\nconst addCssVariables = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/css-var\",\n  transform(token, dictionary) {\n    const { prefix, formatCssVar } = dictionary;\n    const { negative, originalPath } = token.extensions;\n    const path = negative ? originalPath : token.path;\n    return {\n      cssVar: formatCssVar(path.filter(Boolean), prefix)\n    };\n  }\n};\nconst addConditionalCssVariables = {\n  enforce: \"post\",\n  type: \"value\",\n  name: \"tokens/conditionals\",\n  transform(token, dictionary) {\n    const { prefix, formatCssVar } = dictionary;\n    const refs = getReferences(token.value);\n    if (!refs.length) return token.value;\n    refs.forEach((ref) => {\n      const variable = formatCssVar(ref.split(\".\"), prefix);\n      token.value = token.value.replace(`{${variable.ref}}`, variable);\n    });\n    return token.value;\n  }\n};\nconst addColorPalette = {\n  type: \"extensions\",\n  enforce: \"pre\",\n  name: \"tokens/colors/colorPalette\",\n  match(token) {\n    return token.extensions.category === \"colors\" && !token.extensions.virtual;\n  },\n  transform(token, dict) {\n    let path = token.path.slice();\n    path.pop();\n    path.shift();\n    if (path.length === 0) {\n      const newPath = [...token.path];\n      newPath.shift();\n      path = newPath;\n    }\n    if (path.length === 0) {\n      return {};\n    }\n    const roots = path.reduce((acc, _, i, arr) => {\n      const next = arr.slice(0, i + 1);\n      acc.push(next);\n      return acc;\n    }, []);\n    const root = path[0];\n    const value = dict.formatTokenName(path);\n    const keys = token.path.slice(token.path.indexOf(root) + 1).reduce((acc, _, i, arr) => {\n      acc.push(arr.slice(i));\n      return acc;\n    }, []);\n    if (keys.length === 0) {\n      keys.push([\"\"]);\n    }\n    return {\n      colorPalette: { value, roots, keys }\n    };\n  }\n};\nconst tokenTransforms = [\n  addCssVariables,\n  addConditionalCssVariables,\n  addColorPalette\n];\n\nexport { addColorPalette, addConditionalCssVariables, addCssVariables, tokenTransforms };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}