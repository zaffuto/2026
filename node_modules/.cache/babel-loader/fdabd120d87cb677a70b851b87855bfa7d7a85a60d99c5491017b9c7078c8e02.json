{"ast":null,"code":"import { CalendarDate as $35ea8db9cb2ccb90$export$99faa760c7908e4f } from \"./CalendarDate.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nconst $62225008020f0a13$var$ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst $62225008020f0a13$var$ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst $62225008020f0a13$var$ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst $62225008020f0a13$var$ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\nfunction $62225008020f0a13$var$findEraFromGregorianDate(date) {\n  const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day]) => {\n    if (date.year < year) return true;\n    if (date.year === year && date.month < month) return true;\n    if (date.year === year && date.month === month && date.day < day) return true;\n    return false;\n  });\n  if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;\n  if (idx === 0) return 0;\n  return idx - 1;\n}\nfunction $62225008020f0a13$var$toGregorian(date) {\n  let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) throw new Error('Unknown era: ' + date.era);\n  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);\n}\nclass $62225008020f0a13$export$b746ab2b60cdffbf extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {\n  fromJulianDay(jd) {\n    let date = super.fromJulianDay(jd);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(date);\n    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);\n  }\n  toJulianDay(date) {\n    return super.toJulianDay($62225008020f0a13$var$toGregorian(date));\n  }\n  balanceDate(date) {\n    let gregorianDate = $62225008020f0a13$var$toGregorian(date);\n    let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);\n    if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {\n      date.era = $62225008020f0a13$var$ERA_NAMES[era];\n      date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];\n    }\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n  constrainDate(date) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let end = $62225008020f0a13$var$ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n        if (date.month === endMonth) date.day = Math.min(endDay, date.day);\n      }\n    }\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n      if (date.month === startMonth) date.day = Math.max(startDay, date.day);\n    }\n  }\n  getEras() {\n    return $62225008020f0a13$var$ERA_NAMES;\n  }\n  getYearsInEra(date) {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    let cur = $62225008020f0a13$var$ERA_START_DATES[era];\n    let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];\n    if (next == null)\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    let years = next[0] - cur[0];\n    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;\n    return years;\n  }\n  getDaysInMonth(date) {\n    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));\n  }\n  getMinimumMonthInYear(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start ? start[1] : 1;\n  }\n  getMinimumDayInMonth(date) {\n    let start = $62225008020f0a13$var$getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n  constructor(...args) {\n    super(...args), this.identifier = 'japanese';\n  }\n}\nfunction $62225008020f0a13$var$getMinimums(date) {\n  if (date.year === 1) {\n    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);\n    return $62225008020f0a13$var$ERA_START_DATES[idx];\n  }\n}\nexport { $62225008020f0a13$export$b746ab2b60cdffbf as JapaneseCalendar };","map":{"version":3,"names":["$62225008020f0a13$var$ERA_START_DATES","$62225008020f0a13$var$ERA_END_DATES","$62225008020f0a13$var$ERA_ADDENDS","$62225008020f0a13$var$ERA_NAMES","$62225008020f0a13$var$findEraFromGregorianDate","date","idx","findIndex","year","month","day","length","$62225008020f0a13$var$toGregorian","eraAddend","indexOf","era","Error","$35ea8db9cb2ccb90$export$99faa760c7908e4f","$62225008020f0a13$export$b746ab2b60cdffbf","$3b62074eb05584b2$export$80ee6245ec4f29ec","fromJulianDay","jd","toJulianDay","balanceDate","gregorianDate","constrainDate","end","endYear","endMonth","endDay","maxYear","Math","max","min","startMonth","startDay","getEras","getYearsInEra","cur","next","years","getDaysInMonth","getMinimumMonthInYear","start","$62225008020f0a13$var$getMinimums","getMinimumDayInMonth","args","identifier"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@internationalized/date/dist/packages/@internationalized/date/src/calendars/JapaneseCalendar.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from the TC39 Temporal proposal.\n// Original licensing can be found in the NOTICE file in the root directory of this source tree.\n\nimport {AnyCalendarDate} from '../types';\nimport {CalendarDate} from '../CalendarDate';\nimport {GregorianCalendar} from './GregorianCalendar';\nimport {Mutable} from '../utils';\n\nconst ERA_START_DATES = [[1868, 9, 8], [1912, 7, 30], [1926, 12, 25], [1989, 1, 8], [2019, 5, 1]];\nconst ERA_END_DATES = [[1912, 7, 29], [1926, 12, 24], [1989, 1, 7], [2019, 4, 30]];\nconst ERA_ADDENDS = [1867, 1911, 1925, 1988, 2018];\nconst ERA_NAMES = ['meiji', 'taisho', 'showa', 'heisei', 'reiwa'];\n\nfunction findEraFromGregorianDate(date: AnyCalendarDate) {\n  const idx = ERA_START_DATES.findIndex(([year, month, day]) => {\n    if (date.year < year) {\n      return true;\n    }\n\n    if (date.year === year && date.month < month) {\n      return true;\n    }\n\n    if (date.year === year && date.month === month && date.day < day) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (idx === -1) {\n    return ERA_START_DATES.length - 1;\n  }\n\n  if (idx === 0) {\n    return 0;\n  }\n\n  return idx - 1;\n}\n\nfunction toGregorian(date: AnyCalendarDate) {\n  let eraAddend = ERA_ADDENDS[ERA_NAMES.indexOf(date.era)];\n  if (!eraAddend) {\n    throw new Error('Unknown era: ' + date.era);\n  }\n\n  return new CalendarDate(\n    date.year + eraAddend,\n    date.month,\n    date.day\n  );\n}\n\n/**\n * The Japanese calendar is based on the Gregorian calendar, but with eras for the reign of each Japanese emperor.\n * Whenever a new emperor ascends to the throne, a new era begins and the year starts again from 1.\n * Note that eras before 1868 (Gregorian) are not currently supported by this implementation.\n */\nexport class JapaneseCalendar extends GregorianCalendar {\n  identifier = 'japanese';\n\n  fromJulianDay(jd: number): CalendarDate {\n    let date = super.fromJulianDay(jd);\n    let era = findEraFromGregorianDate(date);\n\n    return new CalendarDate(\n      this,\n      ERA_NAMES[era],\n      date.year - ERA_ADDENDS[era],\n      date.month,\n      date.day\n    );\n  }\n\n  toJulianDay(date: AnyCalendarDate) {\n    return super.toJulianDay(toGregorian(date));\n  }\n\n  balanceDate(date: Mutable<AnyCalendarDate>) {\n    let gregorianDate = toGregorian(date);\n    let era = findEraFromGregorianDate(gregorianDate);\n\n    if (ERA_NAMES[era] !== date.era) {\n      date.era = ERA_NAMES[era];\n      date.year = gregorianDate.year - ERA_ADDENDS[era];\n    }\n\n    // Constrain in case we went before the first supported era.\n    this.constrainDate(date);\n  }\n\n  constrainDate(date: Mutable<AnyCalendarDate>) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    let end = ERA_END_DATES[idx];\n    if (end != null) {\n      let [endYear, endMonth, endDay] = end;\n\n      // Constrain the year to the maximum possible value in the era.\n      // Then constrain the month and day fields within that.\n      let maxYear = endYear - ERA_ADDENDS[idx];\n      date.year = Math.max(1, Math.min(maxYear, date.year));\n      if (date.year === maxYear) {\n        date.month = Math.min(endMonth, date.month);\n\n        if (date.month === endMonth) {\n          date.day = Math.min(endDay, date.day);\n        }\n      }\n    }\n\n    if (date.year === 1 && idx >= 0) {\n      let [, startMonth, startDay] = ERA_START_DATES[idx];\n      date.month = Math.max(startMonth, date.month);\n\n      if (date.month === startMonth) {\n        date.day = Math.max(startDay, date.day);\n      }\n    }\n  }\n\n  getEras() {\n    return ERA_NAMES;\n  }\n\n  getYearsInEra(date: AnyCalendarDate): number {\n    // Get the number of years in the era, taking into account the date's month and day fields.\n    let era = ERA_NAMES.indexOf(date.era);\n    let cur = ERA_START_DATES[era];\n    let next = ERA_START_DATES[era + 1];\n    if (next == null) {\n      // 9999 gregorian is the maximum year allowed.\n      return 9999 - cur[0] + 1;\n    }\n\n    let years = next[0] - cur[0];\n\n    if (date.month < next[1] || (date.month === next[1] && date.day < next[2])) {\n      years++;\n    }\n\n    return years;\n  }\n\n  getDaysInMonth(date: AnyCalendarDate): number {\n    return super.getDaysInMonth(toGregorian(date));\n  }\n\n  getMinimumMonthInYear(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start ? start[1] : 1;\n  }\n\n  getMinimumDayInMonth(date: AnyCalendarDate): number {\n    let start = getMinimums(date);\n    return start && date.month === start[1] ? start[2] : 1;\n  }\n}\n\nfunction getMinimums(date: AnyCalendarDate) {\n  if (date.year === 1) {\n    let idx = ERA_NAMES.indexOf(date.era);\n    return ERA_START_DATES[idx];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}