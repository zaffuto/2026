{"ast":null,"code":"import { epochFromDate as $11d87f3f76e88657$export$bd4fb2bc8bb06fb, fromAbsolute as $11d87f3f76e88657$export$1b96692a1ba042ac, toAbsolute as $11d87f3f76e88657$export$5107c82f94518f5c, toCalendar as $11d87f3f76e88657$export$b4a036af3fc0b032, toCalendarDateTime as $11d87f3f76e88657$export$b21e0b124e224484 } from \"./conversion.mjs\";\nimport { GregorianCalendar as $3b62074eb05584b2$export$80ee6245ec4f29ec } from \"./GregorianCalendar.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $735220c2d4774dd3$var$ONE_HOUR = 3600000;\nfunction $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {\n  let mutableDate = date.copy();\n  let days = 'hour' in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;\n  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);\n  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);\n  mutableDate.month += duration.months || 0;\n  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);\n  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);\n  mutableDate.day += (duration.weeks || 0) * 7;\n  mutableDate.day += duration.days || 0;\n  mutableDate.day += days;\n  $735220c2d4774dd3$var$balanceDay(mutableDate);\n  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);\n  // Constrain in case adding ended up with a date outside the valid range for the calendar system.\n  // The behavior here is slightly different than when constraining in the `set` function in that\n  // we adjust smaller fields to their minimum/maximum values rather than constraining each field\n  // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\n  if (mutableDate.year < 1) {\n    mutableDate.year = 1;\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\n  if (mutableDate.year > maxYear) {\n    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;\n    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);\n    mutableDate.year = maxYear;\n    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\n    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n  if (mutableDate.month < 1) {\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\n  if (mutableDate.month > maxMonth) {\n    mutableDate.month = maxMonth;\n    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\n  return mutableDate;\n}\nfunction $735220c2d4774dd3$var$addYears(date, years) {\n  var _date_calendar_isInverseEra, _date_calendar;\n  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;\n  date.year += years;\n}\nfunction $735220c2d4774dd3$var$balanceYearMonth(date) {\n  while (date.month < 1) {\n    $735220c2d4774dd3$var$addYears(date, -1);\n    date.month += date.calendar.getMonthsInYear(date);\n  }\n  let monthsInYear = 0;\n  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {\n    date.month -= monthsInYear;\n    $735220c2d4774dd3$var$addYears(date, 1);\n  }\n}\nfunction $735220c2d4774dd3$var$balanceDay(date) {\n  while (date.day < 1) {\n    date.month--;\n    $735220c2d4774dd3$var$balanceYearMonth(date);\n    date.day += date.calendar.getDaysInMonth(date);\n  }\n  while (date.day > date.calendar.getDaysInMonth(date)) {\n    date.day -= date.calendar.getDaysInMonth(date);\n    date.month++;\n    $735220c2d4774dd3$var$balanceYearMonth(date);\n  }\n}\nfunction $735220c2d4774dd3$var$constrainMonthDay(date) {\n  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\n  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\n}\nfunction $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {\n  if (date.calendar.constrainDate) date.calendar.constrainDate(date);\n  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\n  $735220c2d4774dd3$var$constrainMonthDay(date);\n}\nfunction $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {\n  let inverseDuration = {};\n  for (let key in duration) if (typeof duration[key] === 'number') inverseDuration[key] = -duration[key];\n  return inverseDuration;\n}\nfunction $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {\n  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {\n  let mutableDate = date.copy();\n  if (fields.era != null) mutableDate.era = fields.era;\n  if (fields.year != null) mutableDate.year = fields.year;\n  if (fields.month != null) mutableDate.month = fields.month;\n  if (fields.day != null) mutableDate.day = fields.day;\n  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);\n  return mutableDate;\n}\nfunction $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {\n  let mutableValue = value.copy();\n  if (fields.hour != null) mutableValue.hour = fields.hour;\n  if (fields.minute != null) mutableValue.minute = fields.minute;\n  if (fields.second != null) mutableValue.second = fields.second;\n  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;\n  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);\n  return mutableValue;\n}\nfunction $735220c2d4774dd3$var$balanceTime(time) {\n  time.second += Math.floor(time.millisecond / 1000);\n  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1000);\n  time.minute += Math.floor(time.second / 60);\n  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);\n  time.hour += Math.floor(time.minute / 60);\n  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);\n  let days = Math.floor(time.hour / 24);\n  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);\n  return days;\n}\nfunction $735220c2d4774dd3$export$7555de1e070510cb(time) {\n  time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\n  time.second = Math.max(0, Math.min(time.second, 59));\n  time.minute = Math.max(0, Math.min(time.minute, 59));\n  time.hour = Math.max(0, Math.min(time.hour, 23));\n}\nfunction $735220c2d4774dd3$var$nonNegativeMod(a, b) {\n  let result = a % b;\n  if (result < 0) result += b;\n  return result;\n}\nfunction $735220c2d4774dd3$var$addTimeFields(time, duration) {\n  time.hour += duration.hours || 0;\n  time.minute += duration.minutes || 0;\n  time.second += duration.seconds || 0;\n  time.millisecond += duration.milliseconds || 0;\n  return $735220c2d4774dd3$var$balanceTime(time);\n}\nfunction $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {\n  let res = time.copy();\n  $735220c2d4774dd3$var$addTimeFields(res, duration);\n  return res;\n}\nfunction $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {\n  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {\n  let mutable = value.copy();\n  switch (field) {\n    case 'era':\n      {\n        let eras = value.calendar.getEras();\n        let eraIndex = eras.indexOf(value.era);\n        if (eraIndex < 0) throw new Error('Invalid era: ' + value.era);\n        eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);\n        mutable.era = eras[eraIndex];\n        // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\n        $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n        break;\n      }\n    case 'year':\n      var _mutable_calendar_isInverseEra, _mutable_calendar;\n      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;\n      // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\n      // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\n      // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\n      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);\n      if (mutable.year === -Infinity) mutable.year = 1;\n      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);\n      break;\n    case 'month':\n      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'day':\n      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);\n  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);\n  return mutable;\n}\nfunction $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {\n  let mutable = value.copy();\n  switch (field) {\n    case 'hour':\n      {\n        let hours = value.hour;\n        let min = 0;\n        let max = 23;\n        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n          let isPM = hours >= 12;\n          min = isPM ? 12 : 0;\n          max = isPM ? 23 : 11;\n        }\n        mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min, max, options === null || options === void 0 ? void 0 : options.round);\n        break;\n      }\n    case 'minute':\n      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'second':\n      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    case 'millisecond':\n      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n  return mutable;\n}\nfunction $735220c2d4774dd3$var$cycleValue(value, amount, min, max, round = false) {\n  if (round) {\n    value += Math.sign(amount);\n    if (value < min) value = max;\n    let div = Math.abs(amount);\n    if (amount > 0) value = Math.ceil(value / div) * div;else value = Math.floor(value / div) * div;\n    if (value > max) value = min;\n  } else {\n    value += amount;\n    if (value < min) value = max - (min - value - 1);else if (value > max) value = min + (value - max - 1);\n  }\n  return value;\n}\nfunction $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {\n  let ms;\n  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {\n    let res = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {\n      years: duration.years,\n      months: duration.months,\n      weeks: duration.weeks,\n      days: duration.days\n    });\n    // Changing the date may change the timezone offset, so we need to recompute\n    // using the 'compatible' disambiguation.\n    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n  } else\n    // Otherwise, preserve the offset of the original date.\n    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n  // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\n  // For example, adding one hour during a DST transition may result in the hour field staying the same or\n  // skipping an hour. This results in the offset field changing value instead of the specified field.\n  ms += duration.milliseconds || 0;\n  ms += (duration.seconds || 0) * 1000;\n  ms += (duration.minutes || 0) * 60000;\n  ms += (duration.hours || 0) * 3600000;\n  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);\n  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);\n}\nfunction $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {\n  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));\n}\nfunction $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {\n  // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\n  // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\n  // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\n  switch (field) {\n    case 'hour':\n      {\n        let min = 0;\n        let max = 23;\n        if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {\n          let isPM = dateTime.hour >= 12;\n          min = isPM ? 12 : 0;\n          max = isPM ? 23 : 11;\n        }\n        // The minimum and maximum hour may be affected by daylight saving time.\n        // For example, it might jump forward at midnight, and skip 1am.\n        // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\n        // the possible absolute times for the min and max, and find the maximum range\n        // that is within the current day.\n        let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n        let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n          hour: min\n        }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n        let minAbsolute = [(0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, 'earlier'), (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, 'later')].filter(ms => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === minDate.day)[0];\n        let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {\n          hour: max\n        }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());\n        let maxAbsolute = [(0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, 'earlier'), (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, 'later')].filter(ms => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone).day === maxDate.day).pop();\n        // Since hours may repeat, we need to operate on the absolute time in milliseconds.\n        // This is done in hours from the Unix epoch so that cycleValue works correctly,\n        // and then converted back to milliseconds.\n        let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;\n        let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);\n        let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;\n        ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;\n        // Now compute the new timezone offset, and convert the absolute time back to local time.\n        return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n      }\n    case 'minute':\n    case 'second':\n    case 'millisecond':\n      // @ts-ignore\n      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      {\n        let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);\n        let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);\n        return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n      }\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n}\nfunction $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {\n  // Set the date/time fields, and recompute the UTC offset to account for DST changes.\n  // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\n  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);\n  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);\n  // If the resulting plain date time values are equal, return the original time.\n  // We don't want to change the offset when setting the time to the same value.\n  if (res.compare(plainDateTime) === 0) return dateTime;\n  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);\n  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);\n}\nexport { $735220c2d4774dd3$export$e16d8520af44a096 as add, $735220c2d4774dd3$export$c4e2ecac49351ef2 as constrain, $735220c2d4774dd3$export$3e2544e88a25bff8 as invertDuration, $735220c2d4774dd3$export$4e2d2ead65e5f7e3 as subtract, $735220c2d4774dd3$export$adaa4cf7ef1b65be as set, $735220c2d4774dd3$export$e5d5e1c1822b6e56 as setTime, $735220c2d4774dd3$export$7555de1e070510cb as constrainTime, $735220c2d4774dd3$export$7ed87b6bc2506470 as addTime, $735220c2d4774dd3$export$fe34d3a381cd7501 as subtractTime, $735220c2d4774dd3$export$d52ced6badfb9a4c as cycleDate, $735220c2d4774dd3$export$dd02b3e0007dfe28 as cycleTime, $735220c2d4774dd3$export$96b1d28349274637 as addZoned, $735220c2d4774dd3$export$6814caac34ca03c7 as subtractZoned, $735220c2d4774dd3$export$9a297d111fc86b79 as cycleZoned, $735220c2d4774dd3$export$31b5430eb18be4f8 as setZoned };","map":{"version":3,"names":["$735220c2d4774dd3$var$ONE_HOUR","$735220c2d4774dd3$export$e16d8520af44a096","date","duration","mutableDate","copy","days","$735220c2d4774dd3$var$addTimeFields","$735220c2d4774dd3$var$addYears","years","calendar","balanceYearMonth","month","months","$735220c2d4774dd3$var$balanceYearMonth","$735220c2d4774dd3$var$constrainMonthDay","day","weeks","$735220c2d4774dd3$var$balanceDay","balanceDate","year","maxYear","getYearsInEra","_mutableDate_calendar_isInverseEra","_mutableDate_calendar","isInverseEra","call","getMonthsInYear","getDaysInMonth","maxMonth","Math","max","min","_date_calendar_isInverseEra","_date_calendar","monthsInYear","$735220c2d4774dd3$export$c4e2ecac49351ef2","constrainDate","$735220c2d4774dd3$export$3e2544e88a25bff8","inverseDuration","key","$735220c2d4774dd3$export$4e2d2ead65e5f7e3","$735220c2d4774dd3$export$adaa4cf7ef1b65be","fields","era","$735220c2d4774dd3$export$e5d5e1c1822b6e56","value","mutableValue","hour","minute","second","millisecond","$735220c2d4774dd3$export$7555de1e070510cb","$735220c2d4774dd3$var$balanceTime","time","floor","$735220c2d4774dd3$var$nonNegativeMod","a","b","result","hours","minutes","seconds","milliseconds","$735220c2d4774dd3$export$7ed87b6bc2506470","res","$735220c2d4774dd3$export$fe34d3a381cd7501","$735220c2d4774dd3$export$d52ced6badfb9a4c","field","amount","options","mutable","eras","getEras","eraIndex","indexOf","Error","$735220c2d4774dd3$var$cycleValue","length","round","_mutable_calendar_isInverseEra","_mutable_calendar","Infinity","$735220c2d4774dd3$export$dd02b3e0007dfe28","hourCycle","isPM","sign","div","abs","ceil","$735220c2d4774dd3$export$96b1d28349274637","dateTime","ms","$11d87f3f76e88657$export$b21e0b124e224484","$11d87f3f76e88657$export$5107c82f94518f5c","timeZone","$11d87f3f76e88657$export$bd4fb2bc8bb06fb","offset","$11d87f3f76e88657$export$1b96692a1ba042ac","$11d87f3f76e88657$export$b4a036af3fc0b032","$735220c2d4774dd3$export$6814caac34ca03c7","$735220c2d4774dd3$export$9a297d111fc86b79","plainDateTime","minDate","$3b62074eb05584b2$export$80ee6245ec4f29ec","minAbsolute","filter","maxDate","maxAbsolute","pop","remainder","$735220c2d4774dd3$export$31b5430eb18be4f8","disambiguation","compare"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@internationalized/date/dist/packages/@internationalized/date/src/manipulation.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AnyCalendarDate, AnyDateTime, AnyTime, CycleOptions, CycleTimeOptions, DateDuration, DateField, DateFields, DateTimeDuration, Disambiguation, TimeDuration, TimeField, TimeFields} from './types';\nimport {CalendarDate, CalendarDateTime, Time, ZonedDateTime} from './CalendarDate';\nimport {epochFromDate, fromAbsolute, toAbsolute, toCalendar, toCalendarDateTime} from './conversion';\nimport {GregorianCalendar} from './calendars/GregorianCalendar';\nimport {Mutable} from './utils';\n\nconst ONE_HOUR = 3600000;\n\nexport function add(date: CalendarDateTime, duration: DateTimeDuration): CalendarDateTime;\nexport function add(date: CalendarDate, duration: DateDuration): CalendarDate;\nexport function add(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration): CalendarDate | CalendarDateTime;\nexport function add(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration) {\n  let mutableDate: Mutable<AnyCalendarDate | AnyDateTime> = date.copy();\n  let days = 'hour' in mutableDate ? addTimeFields(mutableDate, duration) : 0;\n\n  addYears(mutableDate, duration.years || 0);\n  if (mutableDate.calendar.balanceYearMonth) {\n    mutableDate.calendar.balanceYearMonth(mutableDate, date);\n  }\n\n  mutableDate.month += duration.months || 0;\n\n  balanceYearMonth(mutableDate);\n  constrainMonthDay(mutableDate);\n\n  mutableDate.day += (duration.weeks || 0) * 7;\n  mutableDate.day += duration.days || 0;\n  mutableDate.day += days;\n\n  balanceDay(mutableDate);\n\n  if (mutableDate.calendar.balanceDate) {\n    mutableDate.calendar.balanceDate(mutableDate);\n  }\n\n  // Constrain in case adding ended up with a date outside the valid range for the calendar system.\n  // The behavior here is slightly different than when constraining in the `set` function in that\n  // we adjust smaller fields to their minimum/maximum values rather than constraining each field\n  // individually. This matches the general behavior of `add` vs `set` regarding how fields are balanced.\n  if (mutableDate.year < 1) {\n    mutableDate.year = 1;\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n\n  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);\n  if (mutableDate.year > maxYear) {\n    let isInverseEra = mutableDate.calendar.isInverseEra?.(mutableDate);\n    mutableDate.year = maxYear;\n    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);\n    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n\n  if (mutableDate.month < 1) {\n    mutableDate.month = 1;\n    mutableDate.day = 1;\n  }\n\n  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);\n  if (mutableDate.month > maxMonth) {\n    mutableDate.month = maxMonth;\n    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);\n  }\n\n  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));\n  return mutableDate;\n}\n\nfunction addYears(date: Mutable<AnyCalendarDate>, years: number) {\n  if (date.calendar.isInverseEra?.(date)) {\n    years = -years;\n  }\n\n  date.year += years;\n}\n\nfunction balanceYearMonth(date: Mutable<AnyCalendarDate>) {\n  while (date.month < 1) {\n    addYears(date, -1);\n    date.month += date.calendar.getMonthsInYear(date);\n  }\n\n  let monthsInYear = 0;\n  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {\n    date.month -= monthsInYear;\n    addYears(date, 1);\n  }\n}\n\nfunction balanceDay(date: Mutable<AnyCalendarDate>) {\n  while (date.day < 1) {\n    date.month--;\n    balanceYearMonth(date);\n    date.day += date.calendar.getDaysInMonth(date);\n  }\n\n  while (date.day > date.calendar.getDaysInMonth(date)) {\n    date.day -= date.calendar.getDaysInMonth(date);\n    date.month++;\n    balanceYearMonth(date);\n  }\n}\n\nfunction constrainMonthDay(date: Mutable<AnyCalendarDate>) {\n  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));\n  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));\n}\n\nexport function constrain(date: Mutable<AnyCalendarDate>) {\n  if (date.calendar.constrainDate) {\n    date.calendar.constrainDate(date);\n  }\n\n  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));\n  constrainMonthDay(date);\n}\n\nexport function invertDuration(duration: DateTimeDuration): DateTimeDuration {\n  let inverseDuration = {};\n  for (let key in duration) {\n    if (typeof duration[key] === 'number') {\n      inverseDuration[key] = -duration[key];\n    }\n  }\n\n  return inverseDuration;\n}\n\nexport function subtract(date: CalendarDateTime, duration: DateTimeDuration): CalendarDateTime;\nexport function subtract(date: CalendarDate, duration: DateDuration): CalendarDate;\nexport function subtract(date: CalendarDate | CalendarDateTime, duration: DateTimeDuration): CalendarDate | CalendarDateTime {\n  return add(date, invertDuration(duration));\n}\n\nexport function set(date: CalendarDateTime, fields: DateFields): CalendarDateTime;\nexport function set(date: CalendarDate, fields: DateFields): CalendarDate;\nexport function set(date: CalendarDate | CalendarDateTime, fields: DateFields) {\n  let mutableDate: Mutable<AnyCalendarDate> = date.copy();\n\n  if (fields.era != null) {\n    mutableDate.era = fields.era;\n  }\n\n  if (fields.year != null) {\n    mutableDate.year = fields.year;\n  }\n\n  if (fields.month != null) {\n    mutableDate.month = fields.month;\n  }\n\n  if (fields.day != null) {\n    mutableDate.day = fields.day;\n  }\n\n  constrain(mutableDate);\n  return mutableDate;\n}\n\nexport function setTime(value: CalendarDateTime, fields: TimeFields): CalendarDateTime;\nexport function setTime(value: Time, fields: TimeFields): Time;\nexport function setTime(value: Time | CalendarDateTime, fields: TimeFields) {\n  let mutableValue: Mutable<Time | CalendarDateTime> = value.copy();\n\n  if (fields.hour != null) {\n    mutableValue.hour = fields.hour;\n  }\n\n  if (fields.minute != null) {\n    mutableValue.minute = fields.minute;\n  }\n\n  if (fields.second != null) {\n    mutableValue.second = fields.second;\n  }\n\n  if (fields.millisecond != null) {\n    mutableValue.millisecond = fields.millisecond;\n  }\n\n  constrainTime(mutableValue);\n  return mutableValue;\n}\n\nfunction balanceTime(time: Mutable<AnyTime>): number {\n  time.second += Math.floor(time.millisecond / 1000);\n  time.millisecond = nonNegativeMod(time.millisecond, 1000);\n\n  time.minute += Math.floor(time.second / 60);\n  time.second = nonNegativeMod(time.second, 60);\n\n  time.hour += Math.floor(time.minute / 60);\n  time.minute = nonNegativeMod(time.minute, 60);\n\n  let days = Math.floor(time.hour / 24);\n  time.hour = nonNegativeMod(time.hour, 24);\n\n  return days;\n}\n\nexport function constrainTime(time: Mutable<AnyTime>) {\n  time.millisecond = Math.max(0, Math.min(time.millisecond, 1000));\n  time.second = Math.max(0, Math.min(time.second, 59));\n  time.minute = Math.max(0, Math.min(time.minute, 59));\n  time.hour = Math.max(0, Math.min(time.hour, 23));\n}\n\nfunction nonNegativeMod(a: number, b: number) {\n  let result = a % b;\n  if (result < 0) {\n    result += b;\n  }\n  return result;\n}\n\nfunction addTimeFields(time: Mutable<AnyTime>, duration: TimeDuration): number {\n  time.hour += duration.hours || 0;\n  time.minute += duration.minutes || 0;\n  time.second += duration.seconds || 0;\n  time.millisecond += duration.milliseconds || 0;\n  return balanceTime(time);\n}\n\nexport function addTime(time: Time, duration: TimeDuration): Time {\n  let res = time.copy();\n  addTimeFields(res, duration);\n  return res;\n}\n\nexport function subtractTime(time: Time, duration: TimeDuration): Time {\n  return addTime(time, invertDuration(duration));\n}\n\nexport function cycleDate(value: CalendarDateTime, field: DateField, amount: number, options?: CycleOptions): CalendarDateTime;\nexport function cycleDate(value: CalendarDate, field: DateField, amount: number, options?: CycleOptions): CalendarDate;\nexport function cycleDate(value: CalendarDate | CalendarDateTime, field: DateField, amount: number, options?: CycleOptions) {\n  let mutable: Mutable<CalendarDate | CalendarDateTime> = value.copy();\n\n  switch (field) {\n    case 'era': {\n      let eras = value.calendar.getEras();\n      let eraIndex = eras.indexOf(value.era);\n      if (eraIndex < 0) {\n        throw new Error('Invalid era: ' + value.era);\n      }\n      eraIndex = cycleValue(eraIndex, amount, 0, eras.length - 1, options?.round);\n      mutable.era = eras[eraIndex];\n\n      // Constrain the year and other fields within the era, so the era doesn't change when we balance below.\n      constrain(mutable);\n      break;\n    }\n    case 'year': {\n      if (mutable.calendar.isInverseEra?.(mutable)) {\n        amount = -amount;\n      }\n\n      // The year field should not cycle within the era as that can cause weird behavior affecting other fields.\n      // We need to also allow values < 1 so that decrementing goes to the previous era. If we get -Infinity back\n      // we know we wrapped around after reaching 9999 (the maximum), so set the year back to 1.\n      mutable.year = cycleValue(value.year, amount, -Infinity, 9999, options?.round);\n      if (mutable.year === -Infinity) {\n        mutable.year = 1;\n      }\n\n      if (mutable.calendar.balanceYearMonth) {\n        mutable.calendar.balanceYearMonth(mutable, value);\n      }\n      break;\n    }\n    case 'month':\n      mutable.month = cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options?.round);\n      break;\n    case 'day':\n      mutable.day = cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options?.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n\n  if (value.calendar.balanceDate) {\n    value.calendar.balanceDate(mutable);\n  }\n\n  constrain(mutable);\n  return mutable;\n}\n\nexport function cycleTime(value: CalendarDateTime, field: TimeField, amount: number, options?: CycleTimeOptions): CalendarDateTime;\nexport function cycleTime(value: Time, field: TimeField, amount: number, options?: CycleTimeOptions): Time;\nexport function cycleTime(value: Time | CalendarDateTime, field: TimeField, amount: number, options?: CycleTimeOptions) {\n  let mutable: Mutable<Time | CalendarDateTime> = value.copy();\n\n  switch (field) {\n    case 'hour': {\n      let hours = value.hour;\n      let min = 0;\n      let max = 23;\n      if (options?.hourCycle === 12) {\n        let isPM = hours >= 12;\n        min = isPM ? 12 : 0;\n        max = isPM ? 23 : 11;\n      }\n      mutable.hour = cycleValue(hours, amount, min, max, options?.round);\n      break;\n    }\n    case 'minute':\n      mutable.minute = cycleValue(value.minute, amount, 0, 59, options?.round);\n      break;\n    case 'second':\n      mutable.second = cycleValue(value.second, amount, 0, 59, options?.round);\n      break;\n    case 'millisecond':\n      mutable.millisecond = cycleValue(value.millisecond, amount, 0, 999, options?.round);\n      break;\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n\n  return mutable;\n}\n\nfunction cycleValue(value: number, amount: number, min: number, max: number, round = false) {\n  if (round) {\n    value += Math.sign(amount);\n\n    if (value < min) {\n      value = max;\n    }\n\n    let div = Math.abs(amount);\n    if (amount > 0) {\n      value = Math.ceil(value / div) * div;\n    } else {\n      value = Math.floor(value / div) * div;\n    }\n\n    if (value > max) {\n      value = min;\n    }\n  } else {\n    value += amount;\n    if (value < min) {\n      value = max - (min - value - 1);\n    } else if (value > max) {\n      value = min + (value - max - 1);\n    }\n  }\n\n  return value;\n}\n\nexport function addZoned(dateTime: ZonedDateTime, duration: DateTimeDuration): ZonedDateTime {\n  let ms: number;\n  if ((duration.years != null && duration.years !== 0) || (duration.months != null && duration.months !== 0) || (duration.weeks != null && duration.weeks !== 0) || (duration.days != null && duration.days !== 0)) {\n    let res = add(toCalendarDateTime(dateTime), {\n      years: duration.years,\n      months: duration.months,\n      weeks: duration.weeks,\n      days: duration.days\n    });\n\n    // Changing the date may change the timezone offset, so we need to recompute\n    // using the 'compatible' disambiguation.\n    ms = toAbsolute(res, dateTime.timeZone);\n  } else {\n    // Otherwise, preserve the offset of the original date.\n    ms = epochFromDate(dateTime) - dateTime.offset;\n  }\n\n  // Perform time manipulation in milliseconds rather than on the original time fields to account for DST.\n  // For example, adding one hour during a DST transition may result in the hour field staying the same or\n  // skipping an hour. This results in the offset field changing value instead of the specified field.\n  ms += duration.milliseconds || 0;\n  ms += (duration.seconds || 0) * 1000;\n  ms += (duration.minutes || 0) * 60 * 1000;\n  ms += (duration.hours || 0) * 60 * 60 * 1000;\n\n  let res = fromAbsolute(ms, dateTime.timeZone);\n  return toCalendar(res, dateTime.calendar);\n}\n\nexport function subtractZoned(dateTime: ZonedDateTime, duration: DateTimeDuration): ZonedDateTime {\n  return addZoned(dateTime, invertDuration(duration));\n}\n\nexport function cycleZoned(dateTime: ZonedDateTime, field: DateField | TimeField, amount: number, options?: CycleTimeOptions): ZonedDateTime {\n  // For date fields, we want the time to remain consistent and the UTC offset to potentially change to account for DST changes.\n  // For time fields, we want the time to change by the amount given. This may result in the hour field staying the same, but the UTC\n  // offset changing in the case of a backward DST transition, or skipping an hour in the case of a forward DST transition.\n  switch (field) {\n    case 'hour': {\n      let min = 0;\n      let max = 23;\n      if (options?.hourCycle === 12) {\n        let isPM = dateTime.hour >= 12;\n        min = isPM ? 12 : 0;\n        max = isPM ? 23 : 11;\n      }\n\n      // The minimum and maximum hour may be affected by daylight saving time.\n      // For example, it might jump forward at midnight, and skip 1am.\n      // Or it might end at midnight and repeat the 11pm hour. To handle this, we get\n      // the possible absolute times for the min and max, and find the maximum range\n      // that is within the current day.\n      let plainDateTime = toCalendarDateTime(dateTime);\n      let minDate = toCalendar(setTime(plainDateTime, {hour: min}), new GregorianCalendar());\n      let minAbsolute = [toAbsolute(minDate, dateTime.timeZone, 'earlier'), toAbsolute(minDate, dateTime.timeZone, 'later')]\n        .filter(ms => fromAbsolute(ms, dateTime.timeZone).day === minDate.day)[0];\n\n      let maxDate = toCalendar(setTime(plainDateTime, {hour: max}), new GregorianCalendar());\n      let maxAbsolute = [toAbsolute(maxDate, dateTime.timeZone, 'earlier'), toAbsolute(maxDate, dateTime.timeZone, 'later')]\n        .filter(ms => fromAbsolute(ms, dateTime.timeZone).day === maxDate.day).pop()!;\n\n      // Since hours may repeat, we need to operate on the absolute time in milliseconds.\n      // This is done in hours from the Unix epoch so that cycleValue works correctly,\n      // and then converted back to milliseconds.\n      let ms = epochFromDate(dateTime) - dateTime.offset;\n      let hours = Math.floor(ms / ONE_HOUR);\n      let remainder = ms % ONE_HOUR;\n      ms = cycleValue(\n        hours,\n        amount,\n        Math.floor(minAbsolute / ONE_HOUR),\n        Math.floor(maxAbsolute / ONE_HOUR),\n        options?.round\n      ) * ONE_HOUR + remainder;\n\n      // Now compute the new timezone offset, and convert the absolute time back to local time.\n      return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n    }\n    case 'minute':\n    case 'second':\n    case 'millisecond':\n      // @ts-ignore\n      return cycleTime(dateTime, field, amount, options);\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day': {\n      let res = cycleDate(toCalendarDateTime(dateTime), field, amount, options);\n      let ms = toAbsolute(res, dateTime.timeZone);\n      return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n    }\n    default:\n      throw new Error('Unsupported field ' + field);\n  }\n}\n\nexport function setZoned(dateTime: ZonedDateTime, fields: DateFields & TimeFields, disambiguation?: Disambiguation): ZonedDateTime {\n  // Set the date/time fields, and recompute the UTC offset to account for DST changes.\n  // We also need to validate by converting back to a local time in case hours are skipped during forward DST transitions.\n  let plainDateTime = toCalendarDateTime(dateTime);\n  let res = setTime(set(plainDateTime, fields), fields);\n\n  // If the resulting plain date time values are equal, return the original time.\n  // We don't want to change the offset when setting the time to the same value.\n  if (res.compare(plainDateTime) === 0) {\n    return dateTime;\n  }\n\n  let ms = toAbsolute(res, dateTime.timeZone, disambiguation);\n  return toCalendar(fromAbsolute(ms, dateTime.timeZone), dateTime.calendar);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}