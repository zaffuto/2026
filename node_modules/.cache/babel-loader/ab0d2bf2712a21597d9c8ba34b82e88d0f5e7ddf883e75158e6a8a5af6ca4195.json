{"ast":null,"code":"// src/index.ts\nvar rafId;\nvar observedElements = /* @__PURE__ */new Map();\nvar getRectFn = el => el.getBoundingClientRect();\nfunction trackElementRect(el, options) {\n  const {\n    scope = \"rect\",\n    getRect = getRectFn,\n    onChange\n  } = options;\n  const loop = getLoopFn({\n    scope,\n    getRect\n  });\n  const data = observedElements.get(el);\n  if (!data) {\n    observedElements.set(el, {\n      rect: {},\n      callbacks: [onChange]\n    });\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop);\n    }\n  } else {\n    data.callbacks.push(onChange);\n    onChange(getRect(el));\n  }\n  return function unobserve() {\n    const data2 = observedElements.get(el);\n    if (!data2) return;\n    const index = data2.callbacks.indexOf(onChange);\n    if (index > -1) {\n      data2.callbacks.splice(index, 1);\n    }\n    if (data2.callbacks.length === 0) {\n      observedElements.delete(el);\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nfunction getLoopFn(options) {\n  const {\n    scope,\n    getRect\n  } = options;\n  const isEqual = getEqualityFn(scope);\n  return function loop() {\n    const changedRectsData = [];\n    observedElements.forEach((data, element) => {\n      const newRect = getRect(element);\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect;\n        changedRectsData.push(data);\n      }\n    });\n    changedRectsData.forEach(data => {\n      data.callbacks.forEach(callback => callback(data.rect));\n    });\n    rafId = requestAnimationFrame(loop);\n  };\n}\nvar isEqualSize = (a, b) => a.width === b.width && a.height === b.height;\nvar isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;\nvar isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);\nfunction getEqualityFn(scope) {\n  if (scope === \"size\") return isEqualSize;\n  if (scope === \"position\") return isEqualPosition;\n  return isEqualRect;\n}\nexport { trackElementRect };","map":{"version":3,"names":["rafId","observedElements","Map","getRectFn","el","getBoundingClientRect","trackElementRect","options","scope","getRect","onChange","loop","getLoopFn","data","get","set","rect","callbacks","size","requestAnimationFrame","push","unobserve","data2","index","indexOf","splice","length","delete","cancelAnimationFrame","isEqual","getEqualityFn","changedRectsData","forEach","element","newRect","callback","isEqualSize","a","b","width","height","isEqualPosition","top","left","isEqualRect"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@zag-js/element-rect/dist/index.mjs"],"sourcesContent":["// src/index.ts\nvar rafId;\nvar observedElements = /* @__PURE__ */ new Map();\nvar getRectFn = (el) => el.getBoundingClientRect();\nfunction trackElementRect(el, options) {\n  const { scope = \"rect\", getRect = getRectFn, onChange } = options;\n  const loop = getLoopFn({ scope, getRect });\n  const data = observedElements.get(el);\n  if (!data) {\n    observedElements.set(el, {\n      rect: {},\n      callbacks: [onChange]\n    });\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop);\n    }\n  } else {\n    data.callbacks.push(onChange);\n    onChange(getRect(el));\n  }\n  return function unobserve() {\n    const data2 = observedElements.get(el);\n    if (!data2) return;\n    const index = data2.callbacks.indexOf(onChange);\n    if (index > -1) {\n      data2.callbacks.splice(index, 1);\n    }\n    if (data2.callbacks.length === 0) {\n      observedElements.delete(el);\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nfunction getLoopFn(options) {\n  const { scope, getRect } = options;\n  const isEqual = getEqualityFn(scope);\n  return function loop() {\n    const changedRectsData = [];\n    observedElements.forEach((data, element) => {\n      const newRect = getRect(element);\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect;\n        changedRectsData.push(data);\n      }\n    });\n    changedRectsData.forEach((data) => {\n      data.callbacks.forEach((callback) => callback(data.rect));\n    });\n    rafId = requestAnimationFrame(loop);\n  };\n}\nvar isEqualSize = (a, b) => a.width === b.width && a.height === b.height;\nvar isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;\nvar isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);\nfunction getEqualityFn(scope) {\n  if (scope === \"size\") return isEqualSize;\n  if (scope === \"position\") return isEqualPosition;\n  return isEqualRect;\n}\n\nexport { trackElementRect };\n"],"mappings":"AAAA;AACA,IAAIA,KAAK;AACT,IAAIC,gBAAgB,GAAG,eAAgB,IAAIC,GAAG,CAAC,CAAC;AAChD,IAAIC,SAAS,GAAIC,EAAE,IAAKA,EAAE,CAACC,qBAAqB,CAAC,CAAC;AAClD,SAASC,gBAAgBA,CAACF,EAAE,EAAEG,OAAO,EAAE;EACrC,MAAM;IAAEC,KAAK,GAAG,MAAM;IAAEC,OAAO,GAAGN,SAAS;IAAEO;EAAS,CAAC,GAAGH,OAAO;EACjE,MAAMI,IAAI,GAAGC,SAAS,CAAC;IAAEJ,KAAK;IAAEC;EAAQ,CAAC,CAAC;EAC1C,MAAMI,IAAI,GAAGZ,gBAAgB,CAACa,GAAG,CAACV,EAAE,CAAC;EACrC,IAAI,CAACS,IAAI,EAAE;IACTZ,gBAAgB,CAACc,GAAG,CAACX,EAAE,EAAE;MACvBY,IAAI,EAAE,CAAC,CAAC;MACRC,SAAS,EAAE,CAACP,QAAQ;IACtB,CAAC,CAAC;IACF,IAAIT,gBAAgB,CAACiB,IAAI,KAAK,CAAC,EAAE;MAC/BlB,KAAK,GAAGmB,qBAAqB,CAACR,IAAI,CAAC;IACrC;EACF,CAAC,MAAM;IACLE,IAAI,CAACI,SAAS,CAACG,IAAI,CAACV,QAAQ,CAAC;IAC7BA,QAAQ,CAACD,OAAO,CAACL,EAAE,CAAC,CAAC;EACvB;EACA,OAAO,SAASiB,SAASA,CAAA,EAAG;IAC1B,MAAMC,KAAK,GAAGrB,gBAAgB,CAACa,GAAG,CAACV,EAAE,CAAC;IACtC,IAAI,CAACkB,KAAK,EAAE;IACZ,MAAMC,KAAK,GAAGD,KAAK,CAACL,SAAS,CAACO,OAAO,CAACd,QAAQ,CAAC;IAC/C,IAAIa,KAAK,GAAG,CAAC,CAAC,EAAE;MACdD,KAAK,CAACL,SAAS,CAACQ,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IAClC;IACA,IAAID,KAAK,CAACL,SAAS,CAACS,MAAM,KAAK,CAAC,EAAE;MAChCzB,gBAAgB,CAAC0B,MAAM,CAACvB,EAAE,CAAC;MAC3B,IAAIH,gBAAgB,CAACiB,IAAI,KAAK,CAAC,EAAE;QAC/BU,oBAAoB,CAAC5B,KAAK,CAAC;MAC7B;IACF;EACF,CAAC;AACH;AACA,SAASY,SAASA,CAACL,OAAO,EAAE;EAC1B,MAAM;IAAEC,KAAK;IAAEC;EAAQ,CAAC,GAAGF,OAAO;EAClC,MAAMsB,OAAO,GAAGC,aAAa,CAACtB,KAAK,CAAC;EACpC,OAAO,SAASG,IAAIA,CAAA,EAAG;IACrB,MAAMoB,gBAAgB,GAAG,EAAE;IAC3B9B,gBAAgB,CAAC+B,OAAO,CAAC,CAACnB,IAAI,EAAEoB,OAAO,KAAK;MAC1C,MAAMC,OAAO,GAAGzB,OAAO,CAACwB,OAAO,CAAC;MAChC,IAAI,CAACJ,OAAO,CAAChB,IAAI,CAACG,IAAI,EAAEkB,OAAO,CAAC,EAAE;QAChCrB,IAAI,CAACG,IAAI,GAAGkB,OAAO;QACnBH,gBAAgB,CAACX,IAAI,CAACP,IAAI,CAAC;MAC7B;IACF,CAAC,CAAC;IACFkB,gBAAgB,CAACC,OAAO,CAAEnB,IAAI,IAAK;MACjCA,IAAI,CAACI,SAAS,CAACe,OAAO,CAAEG,QAAQ,IAAKA,QAAQ,CAACtB,IAAI,CAACG,IAAI,CAAC,CAAC;IAC3D,CAAC,CAAC;IACFhB,KAAK,GAAGmB,qBAAqB,CAACR,IAAI,CAAC;EACrC,CAAC;AACH;AACA,IAAIyB,WAAW,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACE,KAAK,KAAKD,CAAC,CAACC,KAAK,IAAIF,CAAC,CAACG,MAAM,KAAKF,CAAC,CAACE,MAAM;AACxE,IAAIC,eAAe,GAAGA,CAACJ,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACK,GAAG,KAAKJ,CAAC,CAACI,GAAG,IAAIL,CAAC,CAACM,IAAI,KAAKL,CAAC,CAACK,IAAI;AACpE,IAAIC,WAAW,GAAGA,CAACP,CAAC,EAAEC,CAAC,KAAKF,WAAW,CAACC,CAAC,EAAEC,CAAC,CAAC,IAAIG,eAAe,CAACJ,CAAC,EAAEC,CAAC,CAAC;AACtE,SAASR,aAAaA,CAACtB,KAAK,EAAE;EAC5B,IAAIA,KAAK,KAAK,MAAM,EAAE,OAAO4B,WAAW;EACxC,IAAI5B,KAAK,KAAK,UAAU,EAAE,OAAOiC,eAAe;EAChD,OAAOG,WAAW;AACpB;AAEA,SAAStC,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}