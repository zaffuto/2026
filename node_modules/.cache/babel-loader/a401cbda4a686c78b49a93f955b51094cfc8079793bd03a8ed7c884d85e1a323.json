{"ast":null,"code":"import { getValuePercent, getPercentValue, snapValueToStep, clampValue, toFixedNumber, mod } from '@zag-js/utils';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, key + \"\", value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`, `hsl(${zValue}, 100%, 50%)`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, \"hsl(0, 0%, 50%)\"].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [`linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`, `hsl(${zValue}, 100%, 50%)`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, \"#000\"].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const {\n    xChannel,\n    yChannel,\n    dir: dirProp = \"ltr\"\n  } = options;\n  const {\n    zChannel\n  } = color.getColorAxes({\n    xChannel,\n    yChannel\n  });\n  const zValue = color.getChannelValue(zChannel);\n  const {\n    minValue: zMin,\n    maxValue: zMax\n  } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = {\n    areaStyles: {},\n    areaGradientStyles: {}\n  };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\":\n      {\n        dir = xChannel === \"green\";\n        background = generateRGB_R(orientation, dir, zValue);\n        break;\n      }\n    case \"green\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_G(orientation, dir, zValue);\n        break;\n      }\n    case \"blue\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_B(orientation, dir, zValue);\n        break;\n      }\n    case \"hue\":\n      {\n        dir = xChannel !== \"saturation\";\n        if (isHSL) {\n          background = generateHSL_H(orientation, dir, zValue);\n        } else {\n          background = generateHSB_H(orientation, dir, zValue);\n        }\n        break;\n      }\n    case \"saturation\":\n      {\n        dir = xChannel === \"hue\";\n        if (isHSL) {\n          background = generateHSL_S(orientation, dir, alphaValue);\n        } else {\n          background = generateHSB_S(orientation, dir, alphaValue);\n        }\n        break;\n      }\n    case \"brightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSB_B(orientation, dir, alphaValue);\n        break;\n      }\n    case \"lightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSL_L(orientation, dir, zValue);\n        break;\n      }\n  }\n  return background;\n}\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck ?? this.getChannelValue(channel);\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    return getValuePercent(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);\n    return snapValueToStep(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = clampValue(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let {\n      xChannel,\n      yChannel\n    } = xyChannels;\n    let xCh = xChannel || this.getChannels().find(c => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find(c => c !== xCh);\n    let zCh = this.getChannels().find(c => c !== xCh && c !== yCh);\n    return {\n      xChannel: xCh,\n      yChannel: yCh,\n      zChannel: zCh\n    };\n  }\n  incrementChannel(channel, stepSize) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const value = snapValueToStep(clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue), minValue, maxValue, step);\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let colors = [];\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match?.[1]) {\n      colors = match[1].split(\",\").map(value2 => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(brightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(lightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          style: \"decimal\"\n        };\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          minValue: 0,\n          maxValue: 255,\n          step: 1,\n          pageSize: 17\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      r: this.red,\n      g: this.green,\n      b: this.blue,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(toFixedNumber(this.hue, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(brightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"lightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      l: this.lightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;\n      case \"hsba\":\n        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(toFixedNumber(this.hue, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(lightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"brightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      b: this.brightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = str => {\n  const map = /* @__PURE__ */new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, `#${val}`);\n    if (key.includes(\"gray\")) map.set(key.replace(\"gray\", \"grey\"), `#${val}`);\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = value => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value);\n    Error.captureStackTrace?.(error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = v => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\nexport { Color, getColorAreaGradient, normalizeColor, parseColor };","map":{"version":3,"names":["getValuePercent","getPercentValue","snapValueToStep","clampValue","toFixedNumber","mod","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","generateRGB_R","orientation","dir","zValue","maskImage","Number","result","areaStyles","backgroundImage","areaGradientStyles","WebkitMaskImage","generateRGB_G","generateRGB_B","generateHSL_H","background","join","generateHSL_S","alphaValue","generateHSL_L","generateHSB_H","generateHSB_S","generateHSB_B","getColorAreaGradient","color","options","xChannel","yChannel","dirProp","zChannel","getColorAxes","getChannelValue","minValue","zMin","maxValue","zMax","getChannelRange","isHSL","getFormat","isEqualObject","a","b","keys","length","Color","toHexInt","toFormat","channel","Error","getChannelValuePercent","valueToCheck","getChannelPercentValue","percentToCheck","step","percentValue","withChannelValue","clone","xyChannels","xCh","getChannels","find","c","yCh","zCh","incrementChannel","stepSize","decrementChannel","isEqual","isSame","toJSON","_RGBColor","constructor","red","green","blue","alpha","parse","colors","test","includes","values","replace","slice","split","push","parseInt","splice","match","map","value2","trim","num","i","toString","format","padStart","toUpperCase","Math","round","toHSL","toHSB","min","brightness","max","chroma","saturation","hue","HSBColor","lightness","HSLColor","getChannelFormatOptions","style","formatChannelValue","locale","Intl","NumberFormat","pageSize","r","g","colorChannels","RGBColor","HSL_REGEX","_HSLColor","m","h","s","l","n","toRGB","fn","k","unit","unitDisplay","HSB_REGEX","_HSBColor","nativeColors","makeMap","str","Map","list","val","set","nativeColorMap","parseColor","has","get","error","captureStackTrace","normalizeColor","v"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@zag-js/color-utils/dist/index.mjs"],"sourcesContent":["import { getValuePercent, getPercentValue, snapValueToStep, clampValue, toFixedNumber, mod } from '@zag-js/utils';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, key + \"\" , value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"hsl(0, 0%, 50%)\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,\n        `hsl(${zValue}, 100%, 50%)`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`\n      ].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,\n        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"#000\"\n      ].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const { xChannel, yChannel, dir: dirProp = \"ltr\" } = options;\n  const { zChannel } = color.getColorAxes({ xChannel, yChannel });\n  const zValue = color.getChannelValue(zChannel);\n  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = { areaStyles: {}, areaGradientStyles: {} };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\": {\n      dir = xChannel === \"green\";\n      background = generateRGB_R(orientation, dir, zValue);\n      break;\n    }\n    case \"green\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_G(orientation, dir, zValue);\n      break;\n    }\n    case \"blue\": {\n      dir = xChannel === \"red\";\n      background = generateRGB_B(orientation, dir, zValue);\n      break;\n    }\n    case \"hue\": {\n      dir = xChannel !== \"saturation\";\n      if (isHSL) {\n        background = generateHSL_H(orientation, dir, zValue);\n      } else {\n        background = generateHSB_H(orientation, dir, zValue);\n      }\n      break;\n    }\n    case \"saturation\": {\n      dir = xChannel === \"hue\";\n      if (isHSL) {\n        background = generateHSL_S(orientation, dir, alphaValue);\n      } else {\n        background = generateHSB_S(orientation, dir, alphaValue);\n      }\n      break;\n    }\n    case \"brightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSB_B(orientation, dir, alphaValue);\n      break;\n    }\n    case \"lightness\": {\n      dir = xChannel === \"hue\";\n      background = generateHSL_L(orientation, dir, zValue);\n      break;\n    }\n  }\n  return background;\n}\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck ?? this.getChannelValue(channel);\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    return getValuePercent(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);\n    return snapValueToStep(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const { minValue, maxValue } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = clampValue(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let { xChannel, yChannel } = xyChannels;\n    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);\n    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);\n    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };\n  }\n  incrementChannel(channel, stepSize) {\n    const { minValue, maxValue, step } = this.getChannelRange(channel);\n    const value = snapValueToStep(\n      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue),\n      minValue,\n      maxValue,\n      step\n    );\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let colors = [];\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match?.[1]) {\n      colors = match[1].split(\",\").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { style: \"decimal\" };\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(\n      Math.round(fn(0) * 255),\n      Math.round(fn(8) * 255),\n      Math.round(fn(4) * 255),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"lightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;\n      case \"hsba\":\n        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(\n      Math.round(fn(5) * 255),\n      Math.round(fn(3) * 255),\n      Math.round(fn(1) * 255),\n      toFixedNumber(this.alpha, 2)\n    );\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return { style: \"percent\" };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };\n      case \"saturation\":\n      case \"brightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = (str) => {\n  const map = /* @__PURE__ */ new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, `#${val}`);\n    if (key.includes(\"gray\")) map.set(key.replace(\"gray\", \"grey\"), `#${val}`);\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = (value) => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value);\n    Error.captureStackTrace?.(error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = (v) => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\n\nexport { Color, getColorAreaGradient, normalizeColor, parseColor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}