{"ast":null,"code":"import { createProxy, isChanged, getUntracked, trackMemo } from 'proxy-compare';\n// This is required only for performance.\n// https://github.com/dai-shi/proxy-memoize/issues/68\nconst targetCache = new WeakMap();\n// constants from proxy-compare\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\nconst trackMemoUntrackedObjSet = new WeakSet();\nconst isObject = x => typeof x === 'object' && x !== null;\nconst untrack = (x, seen) => {\n  if (!isObject(x)) return x;\n  const untrackedObj = getUntracked(x);\n  if (untrackedObj) {\n    trackMemo(x);\n    trackMemoUntrackedObjSet.add(untrackedObj);\n    return untrackedObj;\n  }\n  if (!seen.has(x)) {\n    seen.add(x);\n    Object.entries(x).forEach(([k, v]) => {\n      const vv = untrack(v, seen);\n      if (!Object.is(vv, v)) x[k] = vv;\n    });\n  }\n  return x;\n};\nconst touchAffected = (dst, src, affected) => {\n  var _a, _b, _c;\n  if (!isObject(dst) || !isObject(src)) return;\n  const untrackedObj = getUntracked(src);\n  const used = affected.get(untrackedObj || src);\n  if (!used) {\n    if (trackMemoUntrackedObjSet.has(untrackedObj)) {\n      trackMemo(dst);\n    }\n    return;\n  }\n  (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach(key => {\n    Reflect.has(dst, key);\n  });\n  if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n    Reflect.ownKeys(dst);\n  }\n  (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach(key => {\n    Reflect.getOwnPropertyDescriptor(dst, key);\n  });\n  (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach(key => {\n    touchAffected(dst[key], src[key], affected);\n  });\n};\nconst isOriginalEqual = (x, y) => {\n  for (let xx = x; xx; x = xx, xx = getUntracked(xx));\n  for (let yy = y; yy; y = yy, yy = getUntracked(yy));\n  return Object.is(x, y);\n};\n// properties\nconst OBJ_PROPERTY = 'o';\nconst RESULT_PROPERTY = 'r';\nconst AFFECTED_PROPERTY = 'a';\n/**\n * Create a memoized function\n *\n * @example\n * import { memoize } from 'proxy-memoize';\n *\n * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));\n *\n * @param options\n * @param options.size - (default: 1)\n * @param options.noWeakMap - disable tier-1 cache (default: false)\n */\nexport function memoize(fn, options) {\n  var _a;\n  let memoListHead = 0;\n  const size = (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : 1;\n  const memoList = [];\n  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : new WeakMap();\n  const memoizedFn = obj => {\n    const cache = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);\n    if (cache) {\n      return cache;\n    }\n    for (let i = 0; i < size; i += 1) {\n      const memo = memoList[(memoListHead + i) % size];\n      if (!memo) break;\n      const {\n        [OBJ_PROPERTY]: memoObj,\n        [AFFECTED_PROPERTY]: memoAffected,\n        [RESULT_PROPERTY]: memoResult\n      } = memo;\n      if (!isChanged(memoObj, obj, memoAffected, new WeakMap(), isOriginalEqual)) {\n        touchAffected(obj, memoObj, memoAffected);\n        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);\n        return memoResult;\n      }\n    }\n    const affected = new WeakMap();\n    const proxy = createProxy(obj, affected, undefined, targetCache);\n    const result = untrack(fn(proxy), new WeakSet());\n    touchAffected(obj, obj, affected);\n    const entry = {\n      [OBJ_PROPERTY]: obj,\n      [RESULT_PROPERTY]: result,\n      [AFFECTED_PROPERTY]: affected\n    };\n    memoListHead = (memoListHead - 1 + size) % size;\n    memoList[memoListHead] = entry;\n    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);\n    return result;\n  };\n  return memoizedFn;\n}","map":{"version":3,"names":["createProxy","isChanged","getUntracked","trackMemo","targetCache","WeakMap","HAS_KEY_PROPERTY","ALL_OWN_KEYS_PROPERTY","HAS_OWN_KEY_PROPERTY","KEYS_PROPERTY","trackMemoUntrackedObjSet","WeakSet","isObject","x","untrack","seen","untrackedObj","add","has","Object","entries","forEach","k","v","vv","is","touchAffected","dst","src","affected","_a","_b","_c","used","get","key","Reflect","ownKeys","getOwnPropertyDescriptor","isOriginalEqual","y","xx","yy","OBJ_PROPERTY","RESULT_PROPERTY","AFFECTED_PROPERTY","memoize","fn","options","memoListHead","size","memoList","resultCache","noWeakMap","memoizedFn","obj","cache","i","memo","memoObj","memoAffected","memoResult","set","proxy","undefined","result","entry"],"sources":["/Users/macbook/developer/2025/2026/node_modules/proxy-memoize/dist/memoize.js"],"sourcesContent":["import { createProxy, isChanged, getUntracked, trackMemo } from 'proxy-compare';\n// This is required only for performance.\n// https://github.com/dai-shi/proxy-memoize/issues/68\nconst targetCache = new WeakMap();\n// constants from proxy-compare\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\nconst trackMemoUntrackedObjSet = new WeakSet();\nconst isObject = (x) => typeof x === 'object' && x !== null;\nconst untrack = (x, seen) => {\n    if (!isObject(x))\n        return x;\n    const untrackedObj = getUntracked(x);\n    if (untrackedObj) {\n        trackMemo(x);\n        trackMemoUntrackedObjSet.add(untrackedObj);\n        return untrackedObj;\n    }\n    if (!seen.has(x)) {\n        seen.add(x);\n        Object.entries(x).forEach(([k, v]) => {\n            const vv = untrack(v, seen);\n            if (!Object.is(vv, v))\n                x[k] = vv;\n        });\n    }\n    return x;\n};\nconst touchAffected = (dst, src, affected) => {\n    var _a, _b, _c;\n    if (!isObject(dst) || !isObject(src))\n        return;\n    const untrackedObj = getUntracked(src);\n    const used = affected.get(untrackedObj || src);\n    if (!used) {\n        if (trackMemoUntrackedObjSet.has(untrackedObj)) {\n            trackMemo(dst);\n        }\n        return;\n    }\n    (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n        Reflect.has(dst, key);\n    });\n    if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n        Reflect.ownKeys(dst);\n    }\n    (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n        Reflect.getOwnPropertyDescriptor(dst, key);\n    });\n    (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n        touchAffected(dst[key], src[key], affected);\n    });\n};\nconst isOriginalEqual = (x, y) => {\n    for (let xx = x; xx; x = xx, xx = getUntracked(xx))\n        ;\n    for (let yy = y; yy; y = yy, yy = getUntracked(yy))\n        ;\n    return Object.is(x, y);\n};\n// properties\nconst OBJ_PROPERTY = 'o';\nconst RESULT_PROPERTY = 'r';\nconst AFFECTED_PROPERTY = 'a';\n/**\n * Create a memoized function\n *\n * @example\n * import { memoize } from 'proxy-memoize';\n *\n * const fn = memoize(obj => ({ sum: obj.a + obj.b, diff: obj.a - obj.b }));\n *\n * @param options\n * @param options.size - (default: 1)\n * @param options.noWeakMap - disable tier-1 cache (default: false)\n */\nexport function memoize(fn, options) {\n    var _a;\n    let memoListHead = 0;\n    const size = (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : 1;\n    const memoList = [];\n    const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : new WeakMap();\n    const memoizedFn = (obj) => {\n        const cache = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);\n        if (cache) {\n            return cache;\n        }\n        for (let i = 0; i < size; i += 1) {\n            const memo = memoList[(memoListHead + i) % size];\n            if (!memo)\n                break;\n            const { [OBJ_PROPERTY]: memoObj, [AFFECTED_PROPERTY]: memoAffected, [RESULT_PROPERTY]: memoResult, } = memo;\n            if (!isChanged(memoObj, obj, memoAffected, new WeakMap(), isOriginalEqual)) {\n                touchAffected(obj, memoObj, memoAffected);\n                resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);\n                return memoResult;\n            }\n        }\n        const affected = new WeakMap();\n        const proxy = createProxy(obj, affected, undefined, targetCache);\n        const result = untrack(fn(proxy), new WeakSet());\n        touchAffected(obj, obj, affected);\n        const entry = {\n            [OBJ_PROPERTY]: obj,\n            [RESULT_PROPERTY]: result,\n            [AFFECTED_PROPERTY]: affected,\n        };\n        memoListHead = (memoListHead - 1 + size) % size;\n        memoList[memoListHead] = entry;\n        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);\n        return result;\n    };\n    return memoizedFn;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}