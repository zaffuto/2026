{"ast":null,"code":"import { isEqual, chunk, compact, isObject, hasProp } from '@zag-js/utils';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar fallback = {\n  itemToValue(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"value\")) return item.value;\n    return \"\";\n  },\n  itemToString(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"label\")) return item.label;\n    return fallback.itemToValue(item);\n  },\n  isItemDisabled(item) {\n    if (isObject(item) && hasProp(item, \"disabled\")) return !!item.disabled;\n    return false;\n  }\n};\nvar ListCollection = class {\n  constructor(options) {\n    this.options = options;\n    /**\n     * The items in the collection\n     */\n    __publicField(this, \"items\");\n    this.items = [...options.items];\n  }\n  isEqual(other) {\n    return isEqual(this.items, other.items);\n  }\n  /**\n   * Function to update the collection items\n   */\n  setItems(items) {\n    this.items = Array.from(items);\n  }\n  /**\n   * Returns all the values in the collection\n   */\n  getValues(items = this.items) {\n    return Array.from(items).map(item => this.getItemValue(item)).filter(Boolean);\n  }\n  /**\n   * Get the item based on its value\n   */\n  find(value) {\n    if (value == null) return null;\n    const index = this.items.findIndex(item => this.getItemValue(item) === value);\n    return index != null ? this.items[index] : null;\n  }\n  /**\n   * Get the items based on its values\n   */\n  findMany(values) {\n    return Array.from(values).map(value => this.find(value)).filter(Boolean);\n  }\n  /**\n   * Get the item based on its index\n   */\n  at(index) {\n    return this.items[index] ?? null;\n  }\n  sortFn(valueA, valueB) {\n    const indexA = this.indexOf(valueA);\n    const indexB = this.indexOf(valueB);\n    return (indexA ?? 0) - (indexB ?? 0);\n  }\n  /**\n   * Sort the values based on their index\n   */\n  sort(values) {\n    return [...values].sort(this.sortFn.bind(this));\n  }\n  /**\n   * Convert an item to a value\n   */\n  getItemValue(item) {\n    if (item == null) return null;\n    return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);\n  }\n  /**\n   * Whether an item is disabled\n   */\n  getItemDisabled(item) {\n    if (item == null) return false;\n    return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);\n  }\n  /**\n   * Convert an item to a string\n   */\n  stringifyItem(item) {\n    if (item == null) return null;\n    return this.options.itemToString?.(item) ?? fallback.itemToString(item);\n  }\n  /**\n   * Convert a value to a string\n   */\n  stringify(value) {\n    if (value == null) return null;\n    return this.stringifyItem(this.find(value));\n  }\n  /**\n   * Convert an array of items to a string\n   */\n  stringifyItems(items, separator = \", \") {\n    return Array.from(items).map(item => this.stringifyItem(item)).filter(Boolean).join(separator);\n  }\n  /**\n   * Convert an array of items to a string\n   */\n  stringifyMany(value, separator) {\n    return this.stringifyItems(this.findMany(value), separator);\n  }\n  /**\n   * Whether the collection has a value\n   */\n  has(value) {\n    return this.indexOf(value) !== -1;\n  }\n  /**\n   * Whether the collection has an item\n   */\n  hasItem(item) {\n    if (item == null) return false;\n    return this.has(this.getItemValue(item));\n  }\n  /**\n   * Returns the number of items in the collection\n   */\n  get size() {\n    return this.items.length;\n  }\n  /**\n   * Returns the first value in the collection\n   */\n  get firstValue() {\n    let index = 0;\n    while (this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the last value in the collection\n   */\n  get lastValue() {\n    let index = this.size - 1;\n    while (this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the next value in the collection\n   */\n  getNextValue(value, step = 1, clamp = false) {\n    let index = this.indexOf(value);\n    if (index === -1) return null;\n    index = clamp ? Math.min(index + step, this.size - 1) : index + step;\n    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the previous value in the collection\n   */\n  getPreviousValue(value, step = 1, clamp = false) {\n    let index = this.indexOf(value);\n    if (index === -1) return null;\n    index = clamp ? Math.max(index - step, 0) : index - step;\n    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Get the index of an item based on its key\n   */\n  indexOf(value) {\n    if (value == null) return -1;\n    return this.items.findIndex(item => this.getItemValue(item) === value);\n  }\n  getByText(text, current) {\n    let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;\n    const isSingleKey = text.length === 1;\n    if (isSingleKey) items = items.filter(item => this.getItemValue(item) !== current);\n    return items.find(item => match(this.stringifyItem(item), text));\n  }\n  /**\n   * Search for a value based on a query\n   */\n  search(queryString, options) {\n    const {\n      state,\n      currentValue,\n      timeout = 350\n    } = options;\n    const search = state.keysSoFar + queryString;\n    const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n    const query = isRepeated ? search[0] : search;\n    const item = this.getByText(query, currentValue);\n    const value = this.getItemValue(item);\n    function cleanup() {\n      clearTimeout(state.timer);\n      state.timer = -1;\n    }\n    function update(value2) {\n      state.keysSoFar = value2;\n      cleanup();\n      if (value2 !== \"\") {\n        state.timer = +setTimeout(() => {\n          update(\"\");\n          cleanup();\n        }, timeout);\n      }\n    }\n    update(search);\n    return value;\n  }\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n  insertBefore(value, item) {\n    const index = this.indexOf(value);\n    if (index === -1) return;\n    this.items.splice(index, 0, item);\n  }\n  insertAfter(value, item) {\n    const index = this.indexOf(value);\n    if (index === -1) return;\n    this.items.splice(index + 1, 0, item);\n  }\n  reorder(fromIndex, toIndex) {\n    if (fromIndex === -1 || toIndex === -1) return;\n    if (fromIndex === toIndex) return;\n    const [removed] = this.items.splice(fromIndex, 1);\n    this.items.splice(toIndex, 0, removed);\n  }\n  json() {\n    return {\n      size: this.size,\n      first: this.firstValue,\n      last: this.lastValue\n    };\n  }\n};\nvar match = (label, query) => {\n  return !!label?.toLowerCase().startsWith(query.toLowerCase());\n};\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\n\n// src/grid-collection.ts\nvar GridCollection = class extends ListCollection {\n  constructor(options) {\n    const {\n      columnCount\n    } = options;\n    super(options);\n    __publicField(this, \"columnCount\");\n    this.columnCount = columnCount;\n  }\n  /**\n   * Returns the row data in the grid\n   */\n  getRows() {\n    return chunk([...this.items], this.columnCount);\n  }\n  /**\n   * Returns the number of rows in the grid\n   */\n  getRowCount() {\n    return this.getRows().length;\n  }\n  /**\n   * Returns the index of the specified row and column in the grid\n   */\n  getCellIndex(row, column) {\n    return row * this.columnCount + column;\n  }\n  /**\n   * Returns the item at the specified row and column in the grid\n   */\n  getCell(row, column) {\n    return this.at(this.getCellIndex(row, column));\n  }\n  /**\n   * Returns the value of the previous row in the grid, based on the current value\n   */\n  getPreviousRowValue(value, clamp = false) {\n    return this.getPreviousValue(value, this.columnCount, clamp);\n  }\n  /**\n   * Returns the value of the next row in the grid, based on the current value\n   */\n  getNextRowValue(value, clamp = false) {\n    return this.getNextValue(value, this.columnCount, clamp);\n  }\n};\n\n// src/tree-visit.ts\nfunction access(node, indexPath, options) {\n  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];\n  return node;\n}\nfunction ancestorIndexPaths(indexPaths) {\n  const sortedPaths = sortIndexPaths(indexPaths);\n  const result = [];\n  const seen = /* @__PURE__ */new Set();\n  for (const indexPath of sortedPaths) {\n    const key = indexPath.join();\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(indexPath);\n    }\n  }\n  return result;\n}\nfunction compareIndexPaths(a, b) {\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    if (a[i] < b[i]) return -1;\n    if (a[i] > b[i]) return 1;\n  }\n  return a.length - b.length;\n}\nfunction sortIndexPaths(indexPaths) {\n  return indexPaths.sort(compareIndexPaths);\n}\nfunction find(node, options) {\n  let found;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = child;\n        return \"stop\";\n      }\n    }\n  });\n  return found;\n}\nfunction findIndexPath(node, options) {\n  let found;\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = [...indexPath];\n        return \"stop\";\n      }\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction reduce(node, options) {\n  let result = options.initialResult;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      result = options.nextResult(result, child, indexPath);\n    }\n  });\n  return result;\n}\nfunction flatMap(node, options) {\n  return reduce(node, {\n    ...options,\n    initialResult: [],\n    nextResult: (result, child, indexPath) => {\n      result.push(...options.transform(child, indexPath));\n      return result;\n    }\n  });\n}\nfunction insertOperation(index, nodes) {\n  return {\n    type: \"insert\",\n    index,\n    nodes\n  };\n}\nfunction removeOperation(indexes) {\n  return {\n    type: \"remove\",\n    indexes\n  };\n}\nfunction replaceOperation() {\n  return {\n    type: \"replace\"\n  };\n}\nfunction splitIndexPath(indexPath) {\n  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];\n}\nfunction getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */new Map()) {\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    switch (operations.get(parentKey)?.type) {\n      case \"remove\":\n        continue;\n    }\n    operations.set(parentKey, replaceOperation());\n  }\n  const operation = operations.get(parentIndexPath.join());\n  switch (operation?.type) {\n    case \"remove\":\n      operations.set(parentIndexPath.join(), {\n        type: \"removeThenInsert\",\n        removeIndexes: operation.indexes,\n        insertIndex: index,\n        insertNodes: nodes\n      });\n      break;\n    default:\n      operations.set(parentIndexPath.join(), insertOperation(index, nodes));\n  }\n  return operations;\n}\nfunction getRemovalOperations(indexPaths) {\n  const operations = /* @__PURE__ */new Map();\n  const indexesToRemove = /* @__PURE__ */new Map();\n  for (const indexPath of indexPaths) {\n    const parentKey = indexPath.slice(0, -1).join();\n    const value = indexesToRemove.get(parentKey) ?? [];\n    value.push(indexPath[indexPath.length - 1]);\n    indexesToRemove.set(parentKey, value.sort((a, b) => a - b));\n  }\n  for (const indexPath of indexPaths) {\n    for (let i = indexPath.length - 2; i >= 0; i--) {\n      const parentKey = indexPath.slice(0, i).join();\n      if (!operations.has(parentKey)) {\n        operations.set(parentKey, replaceOperation());\n      }\n    }\n  }\n  for (const [parentKey, indexes] of indexesToRemove) {\n    operations.set(parentKey, removeOperation(indexes));\n  }\n  return operations;\n}\nfunction getReplaceOperations(indexPath, node) {\n  const operations = /* @__PURE__ */new Map();\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    operations.set(parentKey, replaceOperation());\n  }\n  operations.set(parentIndexPath.join(), {\n    type: \"removeThenInsert\",\n    removeIndexes: [index],\n    insertIndex: index,\n    insertNodes: [node]\n  });\n  return operations;\n}\nfunction mutate(node, operations, options) {\n  return map(node, {\n    ...options,\n    getChildren: (node2, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"replace\":\n        case \"remove\":\n        case \"removeThenInsert\":\n        case \"insert\":\n          return options.getChildren(node2, indexPath);\n        default:\n          return [];\n      }\n    },\n    transform: (node2, children, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"remove\":\n          return options.create(node2, children.filter((_, index) => !operation.indexes.includes(index)), indexPath);\n        case \"removeThenInsert\":\n          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));\n          const adjustedIndex = operation.removeIndexes.reduce((index, removedIndex) => removedIndex < index ? index - 1 : index, operation.insertIndex);\n          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);\n        case \"insert\":\n          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);\n        case \"replace\":\n          return options.create(node2, children, indexPath);\n        default:\n          return node2;\n      }\n    }\n  });\n}\nfunction splice(array, start, deleteCount, ...items) {\n  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n}\nfunction map(node, options) {\n  const childrenMap = {};\n  visit(node, {\n    ...options,\n    onLeave: (child, indexPath) => {\n      const keyIndexPath = [0, ...indexPath];\n      const key = keyIndexPath.join();\n      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);\n      const parentKey = keyIndexPath.slice(0, -1).join();\n      const parentChildren = childrenMap[parentKey] ?? [];\n      parentChildren.push(transformed);\n      childrenMap[parentKey] = parentChildren;\n    }\n  });\n  return childrenMap[\"\"][0];\n}\nfunction insert(node, options) {\n  const {\n    nodes,\n    at\n  } = options;\n  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);\n  const state = getInsertionOperations(at, nodes);\n  return mutate(node, state, options);\n}\nfunction replace(node, options) {\n  if (options.at.length === 0) return options.node;\n  const operations = getReplaceOperations(options.at, options.node);\n  return mutate(node, operations, options);\n}\nfunction remove(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);\n  }\n  const operations = getRemovalOperations(options.indexPaths);\n  return mutate(node, operations, options);\n}\nfunction move(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't move the root node`);\n  }\n  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);\n  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);\n  const nodesToInsert = _ancestorIndexPaths.map(indexPath => access(node, indexPath, options));\n  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));\n  return mutate(node, operations, options);\n}\nfunction visit(node, options) {\n  const {\n    onEnter,\n    onLeave,\n    getChildren\n  } = options;\n  let indexPath = [];\n  let stack = [{\n    node\n  }];\n  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();\n  while (stack.length > 0) {\n    let wrapper = stack[stack.length - 1];\n    if (wrapper.state === void 0) {\n      const enterResult = onEnter?.(wrapper.node, getIndexPath());\n      if (enterResult === \"stop\") return;\n      wrapper.state = enterResult === \"skip\" ? -1 : 0;\n    }\n    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());\n    wrapper.children || (wrapper.children = children);\n    if (wrapper.state !== -1) {\n      if (wrapper.state < children.length) {\n        let currentIndex = wrapper.state;\n        indexPath.push(currentIndex);\n        stack.push({\n          node: children[currentIndex]\n        });\n        wrapper.state = currentIndex + 1;\n        continue;\n      }\n      const leaveResult = onLeave?.(wrapper.node, getIndexPath());\n      if (leaveResult === \"stop\") return;\n    }\n    indexPath.pop();\n    stack.pop();\n  }\n}\n\n// src/tree-collection.ts\nvar TreeCollection = class {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"rootNode\");\n    __publicField(this, \"isEqual\", other => {\n      return isEqual(this.rootNode, other.rootNode);\n    });\n    __publicField(this, \"getNodeChildren\", node => {\n      return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];\n    });\n    __publicField(this, \"getNodeValue\", node => {\n      return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);\n    });\n    __publicField(this, \"getNodeDisabled\", node => {\n      return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);\n    });\n    __publicField(this, \"stringify\", value => {\n      const node = this.findNode(value);\n      if (!node) return null;\n      return this.stringifyNode(node);\n    });\n    __publicField(this, \"stringifyNode\", node => {\n      return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);\n    });\n    __publicField(this, \"getFirstNode\", (rootNode = this.rootNode) => {\n      let firstChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            firstChild = node;\n            return \"stop\";\n          }\n        }\n      });\n      return firstChild;\n    });\n    __publicField(this, \"getLastNode\", (rootNode = this.rootNode, opts = {}) => {\n      let lastChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) return \"skip\";\n          if (indexPath.length > 1) return \"skip\";\n          if (!this.getNodeDisabled(node)) {\n            lastChild = node;\n          }\n        }\n      });\n      return lastChild;\n    });\n    __publicField(this, \"at\", indexPath => {\n      return access(this.rootNode, indexPath, {\n        getChildren: this.getNodeChildren\n      });\n    });\n    __publicField(this, \"findNode\", (value, rootNode = this.rootNode) => {\n      return find(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"sort\", values => {\n      return values.reduce((acc, value) => {\n        const indexPath = this.getIndexPath(value);\n        if (indexPath != null) acc.push({\n          value,\n          indexPath\n        });\n        return acc;\n      }, []).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({\n        value\n      }) => value);\n    });\n    __publicField(this, \"getIndexPath\", value => {\n      return findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"getValue\", indexPath => {\n      const node = this.at(indexPath);\n      return node ? this.getNodeValue(node) : void 0;\n    });\n    __publicField(this, \"getValuePath\", indexPath => {\n      if (!indexPath) return [];\n      const valuePath = [];\n      let currentPath = [...indexPath];\n      while (currentPath.length > 0) {\n        const node = this.at(currentPath);\n        if (node) valuePath.unshift(this.getNodeValue(node));\n        currentPath.pop();\n      }\n      return valuePath;\n    });\n    __publicField(this, \"getDepth\", value => {\n      const indexPath = findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: node => this.getNodeValue(node) === value\n      });\n      return indexPath?.length ?? 0;\n    });\n    __publicField(this, \"isRootNode\", node => {\n      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);\n    });\n    __publicField(this, \"contains\", (parentIndexPath, valueIndexPath) => {\n      if (!parentIndexPath || !valueIndexPath) return false;\n      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);\n    });\n    __publicField(this, \"getNextNode\", (value, opts = {}) => {\n      let found = false;\n      let nextNode;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) {\n            if (nodeValue === value) {\n              found = true;\n            }\n            return \"skip\";\n          }\n          if (found && !this.getNodeDisabled(node)) {\n            nextNode = node;\n            return \"stop\";\n          }\n          if (nodeValue === value) {\n            found = true;\n          }\n        }\n      });\n      return nextNode;\n    });\n    __publicField(this, \"getPreviousNode\", (value, opts = {}) => {\n      let previousNode;\n      let found = false;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) {\n            return \"skip\";\n          }\n          if (nodeValue === value) {\n            found = true;\n            return \"stop\";\n          }\n          if (!this.getNodeDisabled(node)) {\n            previousNode = node;\n          }\n        }\n      });\n      return found ? previousNode : void 0;\n    });\n    __publicField(this, \"getParentNodes\", values => {\n      const result = [];\n      let indexPath = this.getIndexPath(values);\n      while (indexPath && indexPath.length > 0) {\n        indexPath.pop();\n        const parentNode = this.at(indexPath);\n        if (parentNode && !this.isRootNode(parentNode)) {\n          result.unshift(parentNode);\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"getParentIndexPath\", indexPath => {\n      return indexPath.slice(0, -1);\n    });\n    __publicField(this, \"getParentNode\", valueOrIndexPath => {\n      const indexPath = typeof valueOrIndexPath === \"string\" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;\n      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;\n    });\n    __publicField(this, \"visit\", opts => {\n      const {\n        skip,\n        ...rest\n      } = opts;\n      visit(this.rootNode, {\n        ...rest,\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          if (skip?.({\n            value: this.getNodeValue(node),\n            node,\n            indexPath\n          })) return \"skip\";\n          return rest.onEnter?.(node, indexPath);\n        }\n      });\n    });\n    __publicField(this, \"getPreviousSibling\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex(sibling => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (--idx >= 0) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getNextSibling\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex(sibling => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (++idx < siblings.length) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getSiblingNodes\", indexPath => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this.getNodeChildren(parentNode) : [];\n    });\n    __publicField(this, \"getValues\", (rootNode = this.rootNode) => {\n      const values = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: node => [this.getNodeValue(node)]\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"isSameDepth\", (indexPath, depth) => {\n      if (depth == null) return true;\n      return indexPath.length === depth;\n    });\n    __publicField(this, \"isBranchNode\", node => {\n      return this.getNodeChildren(node).length > 0;\n    });\n    __publicField(this, \"getBranchValues\", (rootNode = this.rootNode, opts = {}) => {\n      let values = [];\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({\n            value: nodeValue,\n            node,\n            indexPath\n          })) return \"skip\";\n          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {\n            values.push(this.getNodeValue(node));\n          }\n        }\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"flatten\", (rootNode = this.rootNode) => {\n      const nodes = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node, indexPath) => {\n          const children = this.getNodeChildren(node).map(child => this.getNodeValue(child));\n          return [compact({\n            label: this.stringifyNode(node),\n            value: this.getNodeValue(node),\n            indexPath,\n            children: children.length > 0 ? children : void 0\n          })];\n        }\n      });\n      return nodes.slice(1);\n    });\n    __publicField(this, \"_create\", (node, children) => {\n      return compact({\n        ...node,\n        children\n      });\n    });\n    __publicField(this, \"_insert\", (rootNode, indexPath, nodes) => {\n      return insert(rootNode, {\n        at: indexPath,\n        nodes,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_replace\", (rootNode, indexPath, node) => {\n      return replace(rootNode, {\n        at: indexPath,\n        node,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_move\", (rootNode, indexPaths, to) => {\n      return move(rootNode, {\n        indexPaths,\n        to,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"_remove\", (rootNode, indexPaths) => {\n      return remove(rootNode, {\n        indexPaths,\n        getChildren: this.getNodeChildren,\n        create: this._create\n      });\n    });\n    __publicField(this, \"replace\", (indexPath, node) => {\n      return this._replace(this.rootNode, indexPath, node);\n    });\n    __publicField(this, \"remove\", indexPaths => {\n      return this._remove(this.rootNode, indexPaths);\n    });\n    __publicField(this, \"insertBefore\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;\n    });\n    __publicField(this, \"insertAfter\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const nextIndex = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];\n      return this._insert(this.rootNode, nextIndex, nodes);\n    });\n    __publicField(this, \"move\", (fromIndexPaths, toIndexPath) => {\n      return this._move(this.rootNode, fromIndexPaths, toIndexPath);\n    });\n    __publicField(this, \"json\", () => {\n      return this.getValues(this.rootNode);\n    });\n    this.rootNode = options.rootNode;\n  }\n};\nfunction flattenedToTree(nodes) {\n  let rootNode = {\n    value: \"ROOT\"\n  };\n  nodes.map(node => {\n    const {\n      indexPath,\n      label,\n      value\n    } = node;\n    if (!indexPath.length) {\n      Object.assign(rootNode, {\n        label,\n        value,\n        children: []\n      });\n      return;\n    }\n    rootNode = insert(rootNode, {\n      at: indexPath,\n      nodes: [compact({\n        label,\n        value\n      })],\n      getChildren: node2 => node2.children ?? [],\n      create: (node2, children) => {\n        return compact({\n          ...node2,\n          children\n        });\n      }\n    });\n  });\n  return new TreeCollection({\n    rootNode\n  });\n}\nfunction filePathToTree(paths) {\n  const rootNode = {\n    label: \"\",\n    value: \"ROOT\",\n    children: []\n  };\n  paths.forEach(path => {\n    const parts = path.split(\"/\");\n    let currentNode = rootNode;\n    parts.forEach(part => {\n      let childNode = currentNode.children?.find(child => child.label === part);\n      if (!childNode) {\n        childNode = {\n          value: parts.slice(0, parts.indexOf(part) + 1).join(\"/\"),\n          label: part\n        };\n        currentNode.children || (currentNode.children = []);\n        currentNode.children.push(childNode);\n      }\n      currentNode = childNode;\n    });\n  });\n  return new TreeCollection({\n    rootNode\n  });\n}\nvar fallback2 = {\n  nodeToValue(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"value\")) return node.value;\n    return \"\";\n  },\n  nodeToString(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"label\")) return node.label;\n    return fallback2.nodeToValue(node);\n  },\n  isNodeDisabled(node) {\n    if (isObject(node) && hasProp(node, \"disabled\")) return !!node.disabled;\n    return false;\n  },\n  nodeToChildren(node) {\n    return node.children;\n  }\n};\nexport { GridCollection, ListCollection, TreeCollection, filePathToTree, flattenedToTree };","map":{"version":3,"names":["isEqual","chunk","compact","isObject","hasProp","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","fallback","itemToValue","item","itemToString","label","isItemDisabled","disabled","ListCollection","constructor","options","items","other","setItems","Array","from","getValues","map","getItemValue","filter","Boolean","find","index","findIndex","findMany","values","at","sortFn","valueA","valueB","indexA","indexOf","indexB","sort","bind","getItemDisabled","stringifyItem","stringify","stringifyItems","separator","join","stringifyMany","has","hasItem","size","length","firstValue","lastValue","getNextValue","step","clamp","Math","min","getPreviousValue","max","getByText","text","current","wrap","isSingleKey","match","search","queryString","state","currentValue","timeout","keysSoFar","isRepeated","every","char","query","cleanup","clearTimeout","timer","update","value2","setTimeout","Symbol","iterator","insertBefore","splice","insertAfter","reorder","fromIndex","toIndex","removed","json","first","last","toLowerCase","startsWith","v","idx","_","GridCollection","columnCount","getRows","getRowCount","getCellIndex","row","column","getCell","getPreviousRowValue","getNextRowValue","access","node","indexPath","i","getChildren","slice","ancestorIndexPaths","indexPaths","sortedPaths","sortIndexPaths","result","seen","Set","add","push","compareIndexPaths","a","b","found","visit","onEnter","child","predicate","findIndexPath","reduce","initialResult","nextResult","flatMap","transform","insertOperation","nodes","type","removeOperation","indexes","replaceOperation","splitIndexPath","getInsertionOperations","operations","Map","parentIndexPath","parentKey","get","set","operation","removeIndexes","insertIndex","insertNodes","getRemovalOperations","indexesToRemove","getReplaceOperations","mutate","node2","children","create","includes","updatedChildren","adjustedIndex","removedIndex","array","start","deleteCount","childrenMap","onLeave","keyIndexPath","transformed","parentChildren","insert","Error","replace","remove","move","to","_ancestorIndexPaths","nodesToInsert","stack","getIndexPath","reuseIndexPath","wrapper","enterResult","currentIndex","leaveResult","pop","TreeCollection","rootNode","nodeToChildren","fallback2","nodeToValue","isNodeDisabled","findNode","stringifyNode","nodeToString","firstChild","getNodeChildren","getNodeDisabled","opts","lastChild","nodeValue","getNodeValue","skip","acc","valuePath","currentPath","unshift","valueIndexPath","nextNode","isRootNode","previousNode","parentNode","valueOrIndexPath","getParentIndexPath","rest","getParentNode","siblings","sibling","getValue","depth","isSameDepth","_create","_replace","_remove","_insert","nextIndex","fromIndexPaths","toIndexPath","_move","flattenedToTree","assign","filePathToTree","paths","forEach","path","parts","split","currentNode","part","childNode"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@zag-js/collection/dist/index.mjs"],"sourcesContent":["import { isEqual, chunk, compact, isObject, hasProp } from '@zag-js/utils';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar fallback = {\n  itemToValue(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"value\")) return item.value;\n    return \"\";\n  },\n  itemToString(item) {\n    if (typeof item === \"string\") return item;\n    if (isObject(item) && hasProp(item, \"label\")) return item.label;\n    return fallback.itemToValue(item);\n  },\n  isItemDisabled(item) {\n    if (isObject(item) && hasProp(item, \"disabled\")) return !!item.disabled;\n    return false;\n  }\n};\nvar ListCollection = class {\n  constructor(options) {\n    this.options = options;\n    /**\n     * The items in the collection\n     */\n    __publicField(this, \"items\");\n    this.items = [...options.items];\n  }\n  isEqual(other) {\n    return isEqual(this.items, other.items);\n  }\n  /**\n   * Function to update the collection items\n   */\n  setItems(items) {\n    this.items = Array.from(items);\n  }\n  /**\n   * Returns all the values in the collection\n   */\n  getValues(items = this.items) {\n    return Array.from(items).map((item) => this.getItemValue(item)).filter(Boolean);\n  }\n  /**\n   * Get the item based on its value\n   */\n  find(value) {\n    if (value == null) return null;\n    const index = this.items.findIndex((item) => this.getItemValue(item) === value);\n    return index != null ? this.items[index] : null;\n  }\n  /**\n   * Get the items based on its values\n   */\n  findMany(values) {\n    return Array.from(values).map((value) => this.find(value)).filter(Boolean);\n  }\n  /**\n   * Get the item based on its index\n   */\n  at(index) {\n    return this.items[index] ?? null;\n  }\n  sortFn(valueA, valueB) {\n    const indexA = this.indexOf(valueA);\n    const indexB = this.indexOf(valueB);\n    return (indexA ?? 0) - (indexB ?? 0);\n  }\n  /**\n   * Sort the values based on their index\n   */\n  sort(values) {\n    return [...values].sort(this.sortFn.bind(this));\n  }\n  /**\n   * Convert an item to a value\n   */\n  getItemValue(item) {\n    if (item == null) return null;\n    return this.options.itemToValue?.(item) ?? fallback.itemToValue(item);\n  }\n  /**\n   * Whether an item is disabled\n   */\n  getItemDisabled(item) {\n    if (item == null) return false;\n    return this.options.isItemDisabled?.(item) ?? fallback.isItemDisabled(item);\n  }\n  /**\n   * Convert an item to a string\n   */\n  stringifyItem(item) {\n    if (item == null) return null;\n    return this.options.itemToString?.(item) ?? fallback.itemToString(item);\n  }\n  /**\n   * Convert a value to a string\n   */\n  stringify(value) {\n    if (value == null) return null;\n    return this.stringifyItem(this.find(value));\n  }\n  /**\n   * Convert an array of items to a string\n   */\n  stringifyItems(items, separator = \", \") {\n    return Array.from(items).map((item) => this.stringifyItem(item)).filter(Boolean).join(separator);\n  }\n  /**\n   * Convert an array of items to a string\n   */\n  stringifyMany(value, separator) {\n    return this.stringifyItems(this.findMany(value), separator);\n  }\n  /**\n   * Whether the collection has a value\n   */\n  has(value) {\n    return this.indexOf(value) !== -1;\n  }\n  /**\n   * Whether the collection has an item\n   */\n  hasItem(item) {\n    if (item == null) return false;\n    return this.has(this.getItemValue(item));\n  }\n  /**\n   * Returns the number of items in the collection\n   */\n  get size() {\n    return this.items.length;\n  }\n  /**\n   * Returns the first value in the collection\n   */\n  get firstValue() {\n    let index = 0;\n    while (this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the last value in the collection\n   */\n  get lastValue() {\n    let index = this.size - 1;\n    while (this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the next value in the collection\n   */\n  getNextValue(value, step = 1, clamp = false) {\n    let index = this.indexOf(value);\n    if (index === -1) return null;\n    index = clamp ? Math.min(index + step, this.size - 1) : index + step;\n    while (index <= this.size && this.getItemDisabled(this.at(index))) index++;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Returns the previous value in the collection\n   */\n  getPreviousValue(value, step = 1, clamp = false) {\n    let index = this.indexOf(value);\n    if (index === -1) return null;\n    index = clamp ? Math.max(index - step, 0) : index - step;\n    while (index >= 0 && this.getItemDisabled(this.at(index))) index--;\n    return this.getItemValue(this.at(index));\n  }\n  /**\n   * Get the index of an item based on its key\n   */\n  indexOf(value) {\n    if (value == null) return -1;\n    return this.items.findIndex((item) => this.getItemValue(item) === value);\n  }\n  getByText(text, current) {\n    let items = current != null ? wrap(this.items, this.indexOf(current)) : this.items;\n    const isSingleKey = text.length === 1;\n    if (isSingleKey) items = items.filter((item) => this.getItemValue(item) !== current);\n    return items.find((item) => match(this.stringifyItem(item), text));\n  }\n  /**\n   * Search for a value based on a query\n   */\n  search(queryString, options) {\n    const { state, currentValue, timeout = 350 } = options;\n    const search = state.keysSoFar + queryString;\n    const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n    const query = isRepeated ? search[0] : search;\n    const item = this.getByText(query, currentValue);\n    const value = this.getItemValue(item);\n    function cleanup() {\n      clearTimeout(state.timer);\n      state.timer = -1;\n    }\n    function update(value2) {\n      state.keysSoFar = value2;\n      cleanup();\n      if (value2 !== \"\") {\n        state.timer = +setTimeout(() => {\n          update(\"\");\n          cleanup();\n        }, timeout);\n      }\n    }\n    update(search);\n    return value;\n  }\n  *[Symbol.iterator]() {\n    yield* this.items;\n  }\n  insertBefore(value, item) {\n    const index = this.indexOf(value);\n    if (index === -1) return;\n    this.items.splice(index, 0, item);\n  }\n  insertAfter(value, item) {\n    const index = this.indexOf(value);\n    if (index === -1) return;\n    this.items.splice(index + 1, 0, item);\n  }\n  reorder(fromIndex, toIndex) {\n    if (fromIndex === -1 || toIndex === -1) return;\n    if (fromIndex === toIndex) return;\n    const [removed] = this.items.splice(fromIndex, 1);\n    this.items.splice(toIndex, 0, removed);\n  }\n  json() {\n    return {\n      size: this.size,\n      first: this.firstValue,\n      last: this.lastValue\n    };\n  }\n};\nvar match = (label, query) => {\n  return !!label?.toLowerCase().startsWith(query.toLowerCase());\n};\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\n\n// src/grid-collection.ts\nvar GridCollection = class extends ListCollection {\n  constructor(options) {\n    const { columnCount } = options;\n    super(options);\n    __publicField(this, \"columnCount\");\n    this.columnCount = columnCount;\n  }\n  /**\n   * Returns the row data in the grid\n   */\n  getRows() {\n    return chunk([...this.items], this.columnCount);\n  }\n  /**\n   * Returns the number of rows in the grid\n   */\n  getRowCount() {\n    return this.getRows().length;\n  }\n  /**\n   * Returns the index of the specified row and column in the grid\n   */\n  getCellIndex(row, column) {\n    return row * this.columnCount + column;\n  }\n  /**\n   * Returns the item at the specified row and column in the grid\n   */\n  getCell(row, column) {\n    return this.at(this.getCellIndex(row, column));\n  }\n  /**\n   * Returns the value of the previous row in the grid, based on the current value\n   */\n  getPreviousRowValue(value, clamp = false) {\n    return this.getPreviousValue(value, this.columnCount, clamp);\n  }\n  /**\n   * Returns the value of the next row in the grid, based on the current value\n   */\n  getNextRowValue(value, clamp = false) {\n    return this.getNextValue(value, this.columnCount, clamp);\n  }\n};\n\n// src/tree-visit.ts\nfunction access(node, indexPath, options) {\n  for (let i = 0; i < indexPath.length; i++) node = options.getChildren(node, indexPath.slice(i + 1))[indexPath[i]];\n  return node;\n}\nfunction ancestorIndexPaths(indexPaths) {\n  const sortedPaths = sortIndexPaths(indexPaths);\n  const result = [];\n  const seen = /* @__PURE__ */ new Set();\n  for (const indexPath of sortedPaths) {\n    const key = indexPath.join();\n    if (!seen.has(key)) {\n      seen.add(key);\n      result.push(indexPath);\n    }\n  }\n  return result;\n}\nfunction compareIndexPaths(a, b) {\n  for (let i = 0; i < Math.min(a.length, b.length); i++) {\n    if (a[i] < b[i]) return -1;\n    if (a[i] > b[i]) return 1;\n  }\n  return a.length - b.length;\n}\nfunction sortIndexPaths(indexPaths) {\n  return indexPaths.sort(compareIndexPaths);\n}\nfunction find(node, options) {\n  let found;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = child;\n        return \"stop\";\n      }\n    }\n  });\n  return found;\n}\nfunction findIndexPath(node, options) {\n  let found;\n  visit(node, {\n    onEnter: (child, indexPath) => {\n      if (options.predicate(child, indexPath)) {\n        found = [...indexPath];\n        return \"stop\";\n      }\n    },\n    getChildren: options.getChildren\n  });\n  return found;\n}\nfunction reduce(node, options) {\n  let result = options.initialResult;\n  visit(node, {\n    ...options,\n    onEnter: (child, indexPath) => {\n      result = options.nextResult(result, child, indexPath);\n    }\n  });\n  return result;\n}\nfunction flatMap(node, options) {\n  return reduce(node, {\n    ...options,\n    initialResult: [],\n    nextResult: (result, child, indexPath) => {\n      result.push(...options.transform(child, indexPath));\n      return result;\n    }\n  });\n}\nfunction insertOperation(index, nodes) {\n  return { type: \"insert\", index, nodes };\n}\nfunction removeOperation(indexes) {\n  return { type: \"remove\", indexes };\n}\nfunction replaceOperation() {\n  return { type: \"replace\" };\n}\nfunction splitIndexPath(indexPath) {\n  return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];\n}\nfunction getInsertionOperations(indexPath, nodes, operations = /* @__PURE__ */ new Map()) {\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    switch (operations.get(parentKey)?.type) {\n      case \"remove\":\n        continue;\n    }\n    operations.set(parentKey, replaceOperation());\n  }\n  const operation = operations.get(parentIndexPath.join());\n  switch (operation?.type) {\n    case \"remove\":\n      operations.set(parentIndexPath.join(), {\n        type: \"removeThenInsert\",\n        removeIndexes: operation.indexes,\n        insertIndex: index,\n        insertNodes: nodes\n      });\n      break;\n    default:\n      operations.set(parentIndexPath.join(), insertOperation(index, nodes));\n  }\n  return operations;\n}\nfunction getRemovalOperations(indexPaths) {\n  const operations = /* @__PURE__ */ new Map();\n  const indexesToRemove = /* @__PURE__ */ new Map();\n  for (const indexPath of indexPaths) {\n    const parentKey = indexPath.slice(0, -1).join();\n    const value = indexesToRemove.get(parentKey) ?? [];\n    value.push(indexPath[indexPath.length - 1]);\n    indexesToRemove.set(\n      parentKey,\n      value.sort((a, b) => a - b)\n    );\n  }\n  for (const indexPath of indexPaths) {\n    for (let i = indexPath.length - 2; i >= 0; i--) {\n      const parentKey = indexPath.slice(0, i).join();\n      if (!operations.has(parentKey)) {\n        operations.set(parentKey, replaceOperation());\n      }\n    }\n  }\n  for (const [parentKey, indexes] of indexesToRemove) {\n    operations.set(parentKey, removeOperation(indexes));\n  }\n  return operations;\n}\nfunction getReplaceOperations(indexPath, node) {\n  const operations = /* @__PURE__ */ new Map();\n  const [parentIndexPath, index] = splitIndexPath(indexPath);\n  for (let i = parentIndexPath.length - 1; i >= 0; i--) {\n    const parentKey = parentIndexPath.slice(0, i).join();\n    operations.set(parentKey, replaceOperation());\n  }\n  operations.set(parentIndexPath.join(), {\n    type: \"removeThenInsert\",\n    removeIndexes: [index],\n    insertIndex: index,\n    insertNodes: [node]\n  });\n  return operations;\n}\nfunction mutate(node, operations, options) {\n  return map(node, {\n    ...options,\n    getChildren: (node2, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"replace\":\n        case \"remove\":\n        case \"removeThenInsert\":\n        case \"insert\":\n          return options.getChildren(node2, indexPath);\n        default:\n          return [];\n      }\n    },\n    transform: (node2, children, indexPath) => {\n      const key = indexPath.join();\n      const operation = operations.get(key);\n      switch (operation?.type) {\n        case \"remove\":\n          return options.create(\n            node2,\n            children.filter((_, index) => !operation.indexes.includes(index)),\n            indexPath\n          );\n        case \"removeThenInsert\":\n          const updatedChildren = children.filter((_, index) => !operation.removeIndexes.includes(index));\n          const adjustedIndex = operation.removeIndexes.reduce(\n            (index, removedIndex) => removedIndex < index ? index - 1 : index,\n            operation.insertIndex\n          );\n          return options.create(node2, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);\n        case \"insert\":\n          return options.create(node2, splice(children, operation.index, 0, ...operation.nodes), indexPath);\n        case \"replace\":\n          return options.create(node2, children, indexPath);\n        default:\n          return node2;\n      }\n    }\n  });\n}\nfunction splice(array, start, deleteCount, ...items) {\n  return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];\n}\nfunction map(node, options) {\n  const childrenMap = {};\n  visit(node, {\n    ...options,\n    onLeave: (child, indexPath) => {\n      const keyIndexPath = [0, ...indexPath];\n      const key = keyIndexPath.join();\n      const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);\n      const parentKey = keyIndexPath.slice(0, -1).join();\n      const parentChildren = childrenMap[parentKey] ?? [];\n      parentChildren.push(transformed);\n      childrenMap[parentKey] = parentChildren;\n    }\n  });\n  return childrenMap[\"\"][0];\n}\nfunction insert(node, options) {\n  const { nodes, at } = options;\n  if (at.length === 0) throw new Error(`Can't insert nodes at the root`);\n  const state = getInsertionOperations(at, nodes);\n  return mutate(node, state, options);\n}\nfunction replace(node, options) {\n  if (options.at.length === 0) return options.node;\n  const operations = getReplaceOperations(options.at, options.node);\n  return mutate(node, operations, options);\n}\nfunction remove(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't remove the root node`);\n  }\n  const operations = getRemovalOperations(options.indexPaths);\n  return mutate(node, operations, options);\n}\nfunction move(node, options) {\n  if (options.indexPaths.length === 0) return node;\n  for (const indexPath of options.indexPaths) {\n    if (indexPath.length === 0) throw new Error(`Can't move the root node`);\n  }\n  if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);\n  const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);\n  const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node, indexPath, options));\n  const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));\n  return mutate(node, operations, options);\n}\nfunction visit(node, options) {\n  const { onEnter, onLeave, getChildren } = options;\n  let indexPath = [];\n  let stack = [{ node }];\n  const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();\n  while (stack.length > 0) {\n    let wrapper = stack[stack.length - 1];\n    if (wrapper.state === void 0) {\n      const enterResult = onEnter?.(wrapper.node, getIndexPath());\n      if (enterResult === \"stop\") return;\n      wrapper.state = enterResult === \"skip\" ? -1 : 0;\n    }\n    const children = wrapper.children || getChildren(wrapper.node, getIndexPath());\n    wrapper.children || (wrapper.children = children);\n    if (wrapper.state !== -1) {\n      if (wrapper.state < children.length) {\n        let currentIndex = wrapper.state;\n        indexPath.push(currentIndex);\n        stack.push({ node: children[currentIndex] });\n        wrapper.state = currentIndex + 1;\n        continue;\n      }\n      const leaveResult = onLeave?.(wrapper.node, getIndexPath());\n      if (leaveResult === \"stop\") return;\n    }\n    indexPath.pop();\n    stack.pop();\n  }\n}\n\n// src/tree-collection.ts\nvar TreeCollection = class {\n  constructor(options) {\n    this.options = options;\n    __publicField(this, \"rootNode\");\n    __publicField(this, \"isEqual\", (other) => {\n      return isEqual(this.rootNode, other.rootNode);\n    });\n    __publicField(this, \"getNodeChildren\", (node) => {\n      return this.options.nodeToChildren?.(node) ?? fallback2.nodeToChildren(node) ?? [];\n    });\n    __publicField(this, \"getNodeValue\", (node) => {\n      return this.options.nodeToValue?.(node) ?? fallback2.nodeToValue(node);\n    });\n    __publicField(this, \"getNodeDisabled\", (node) => {\n      return this.options.isNodeDisabled?.(node) ?? fallback2.isNodeDisabled(node);\n    });\n    __publicField(this, \"stringify\", (value) => {\n      const node = this.findNode(value);\n      if (!node) return null;\n      return this.stringifyNode(node);\n    });\n    __publicField(this, \"stringifyNode\", (node) => {\n      return this.options.nodeToString?.(node) ?? fallback2.nodeToString(node);\n    });\n    __publicField(this, \"getFirstNode\", (rootNode = this.rootNode) => {\n      let firstChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node)) {\n            firstChild = node;\n            return \"stop\";\n          }\n        }\n      });\n      return firstChild;\n    });\n    __publicField(this, \"getLastNode\", (rootNode = this.rootNode, opts = {}) => {\n      let lastChild;\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) return \"skip\";\n          if (indexPath.length > 1) return \"skip\";\n          if (!this.getNodeDisabled(node)) {\n            lastChild = node;\n          }\n        }\n      });\n      return lastChild;\n    });\n    __publicField(this, \"at\", (indexPath) => {\n      return access(this.rootNode, indexPath, {\n        getChildren: this.getNodeChildren\n      });\n    });\n    __publicField(this, \"findNode\", (value, rootNode = this.rootNode) => {\n      return find(rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"sort\", (values) => {\n      return values.reduce(\n        (acc, value) => {\n          const indexPath = this.getIndexPath(value);\n          if (indexPath != null) acc.push({ value, indexPath });\n          return acc;\n        },\n        []\n      ).sort((a, b) => compareIndexPaths(a.indexPath, b.indexPath)).map(({ value }) => value);\n    });\n    __publicField(this, \"getIndexPath\", (value) => {\n      return findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n    });\n    __publicField(this, \"getValue\", (indexPath) => {\n      const node = this.at(indexPath);\n      return node ? this.getNodeValue(node) : void 0;\n    });\n    __publicField(this, \"getValuePath\", (indexPath) => {\n      if (!indexPath) return [];\n      const valuePath = [];\n      let currentPath = [...indexPath];\n      while (currentPath.length > 0) {\n        const node = this.at(currentPath);\n        if (node) valuePath.unshift(this.getNodeValue(node));\n        currentPath.pop();\n      }\n      return valuePath;\n    });\n    __publicField(this, \"getDepth\", (value) => {\n      const indexPath = findIndexPath(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        predicate: (node) => this.getNodeValue(node) === value\n      });\n      return indexPath?.length ?? 0;\n    });\n    __publicField(this, \"isRootNode\", (node) => {\n      return this.getNodeValue(node) === this.getNodeValue(this.rootNode);\n    });\n    __publicField(this, \"contains\", (parentIndexPath, valueIndexPath) => {\n      if (!parentIndexPath || !valueIndexPath) return false;\n      return valueIndexPath.slice(0, parentIndexPath.length).every((_, i) => parentIndexPath[i] === valueIndexPath[i]);\n    });\n    __publicField(this, \"getNextNode\", (value, opts = {}) => {\n      let found = false;\n      let nextNode;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            if (nodeValue === value) {\n              found = true;\n            }\n            return \"skip\";\n          }\n          if (found && !this.getNodeDisabled(node)) {\n            nextNode = node;\n            return \"stop\";\n          }\n          if (nodeValue === value) {\n            found = true;\n          }\n        }\n      });\n      return nextNode;\n    });\n    __publicField(this, \"getPreviousNode\", (value, opts = {}) => {\n      let previousNode;\n      let found = false;\n      visit(this.rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) {\n            return \"skip\";\n          }\n          if (nodeValue === value) {\n            found = true;\n            return \"stop\";\n          }\n          if (!this.getNodeDisabled(node)) {\n            previousNode = node;\n          }\n        }\n      });\n      return found ? previousNode : void 0;\n    });\n    __publicField(this, \"getParentNodes\", (values) => {\n      const result = [];\n      let indexPath = this.getIndexPath(values);\n      while (indexPath && indexPath.length > 0) {\n        indexPath.pop();\n        const parentNode = this.at(indexPath);\n        if (parentNode && !this.isRootNode(parentNode)) {\n          result.unshift(parentNode);\n        }\n      }\n      return result;\n    });\n    __publicField(this, \"getParentIndexPath\", (indexPath) => {\n      return indexPath.slice(0, -1);\n    });\n    __publicField(this, \"getParentNode\", (valueOrIndexPath) => {\n      const indexPath = typeof valueOrIndexPath === \"string\" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;\n      return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;\n    });\n    __publicField(this, \"visit\", (opts) => {\n      const { skip, ...rest } = opts;\n      visit(this.rootNode, {\n        ...rest,\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          if (this.isRootNode(node)) return;\n          if (skip?.({ value: this.getNodeValue(node), node, indexPath })) return \"skip\";\n          return rest.onEnter?.(node, indexPath);\n        }\n      });\n    });\n    __publicField(this, \"getPreviousSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (--idx >= 0) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getNextSibling\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const siblings = this.getNodeChildren(parentNode);\n      let idx = siblings.findIndex((sibling) => this.getValue(indexPath) === this.getNodeValue(sibling));\n      while (++idx < siblings.length) {\n        const sibling = siblings[idx];\n        if (!this.getNodeDisabled(sibling)) return sibling;\n      }\n      return;\n    });\n    __publicField(this, \"getSiblingNodes\", (indexPath) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this.getNodeChildren(parentNode) : [];\n    });\n    __publicField(this, \"getValues\", (rootNode = this.rootNode) => {\n      const values = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node) => [this.getNodeValue(node)]\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"isSameDepth\", (indexPath, depth) => {\n      if (depth == null) return true;\n      return indexPath.length === depth;\n    });\n    __publicField(this, \"isBranchNode\", (node) => {\n      return this.getNodeChildren(node).length > 0;\n    });\n    __publicField(this, \"getBranchValues\", (rootNode = this.rootNode, opts = {}) => {\n      let values = [];\n      visit(rootNode, {\n        getChildren: this.getNodeChildren,\n        onEnter: (node, indexPath) => {\n          const nodeValue = this.getNodeValue(node);\n          if (opts.skip?.({ value: nodeValue, node, indexPath })) return \"skip\";\n          if (this.getNodeChildren(node).length > 0 && this.isSameDepth(indexPath, opts.depth)) {\n            values.push(this.getNodeValue(node));\n          }\n        }\n      });\n      return values.slice(1);\n    });\n    __publicField(this, \"flatten\", (rootNode = this.rootNode) => {\n      const nodes = flatMap(rootNode, {\n        getChildren: this.getNodeChildren,\n        transform: (node, indexPath) => {\n          const children = this.getNodeChildren(node).map((child) => this.getNodeValue(child));\n          return [\n            compact({\n              label: this.stringifyNode(node),\n              value: this.getNodeValue(node),\n              indexPath,\n              children: children.length > 0 ? children : void 0\n            })\n          ];\n        }\n      });\n      return nodes.slice(1);\n    });\n    __publicField(this, \"_create\", (node, children) => {\n      return compact({ ...node, children });\n    });\n    __publicField(this, \"_insert\", (rootNode, indexPath, nodes) => {\n      return insert(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_replace\", (rootNode, indexPath, node) => {\n      return replace(rootNode, { at: indexPath, node, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_move\", (rootNode, indexPaths, to) => {\n      return move(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"_remove\", (rootNode, indexPaths) => {\n      return remove(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create });\n    });\n    __publicField(this, \"replace\", (indexPath, node) => {\n      return this._replace(this.rootNode, indexPath, node);\n    });\n    __publicField(this, \"remove\", (indexPaths) => {\n      return this._remove(this.rootNode, indexPaths);\n    });\n    __publicField(this, \"insertBefore\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;\n    });\n    __publicField(this, \"insertAfter\", (indexPath, nodes) => {\n      const parentNode = this.getParentNode(indexPath);\n      if (!parentNode) return;\n      const nextIndex = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];\n      return this._insert(this.rootNode, nextIndex, nodes);\n    });\n    __publicField(this, \"move\", (fromIndexPaths, toIndexPath) => {\n      return this._move(this.rootNode, fromIndexPaths, toIndexPath);\n    });\n    __publicField(this, \"json\", () => {\n      return this.getValues(this.rootNode);\n    });\n    this.rootNode = options.rootNode;\n  }\n};\nfunction flattenedToTree(nodes) {\n  let rootNode = {\n    value: \"ROOT\"\n  };\n  nodes.map((node) => {\n    const { indexPath, label, value } = node;\n    if (!indexPath.length) {\n      Object.assign(rootNode, { label, value, children: [] });\n      return;\n    }\n    rootNode = insert(rootNode, {\n      at: indexPath,\n      nodes: [compact({ label, value })],\n      getChildren: (node2) => node2.children ?? [],\n      create: (node2, children) => {\n        return compact({ ...node2, children });\n      }\n    });\n  });\n  return new TreeCollection({ rootNode });\n}\nfunction filePathToTree(paths) {\n  const rootNode = {\n    label: \"\",\n    value: \"ROOT\",\n    children: []\n  };\n  paths.forEach((path) => {\n    const parts = path.split(\"/\");\n    let currentNode = rootNode;\n    parts.forEach((part) => {\n      let childNode = currentNode.children?.find((child) => child.label === part);\n      if (!childNode) {\n        childNode = {\n          value: parts.slice(0, parts.indexOf(part) + 1).join(\"/\"),\n          label: part\n        };\n        currentNode.children || (currentNode.children = []);\n        currentNode.children.push(childNode);\n      }\n      currentNode = childNode;\n    });\n  });\n  return new TreeCollection({ rootNode });\n}\nvar fallback2 = {\n  nodeToValue(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"value\")) return node.value;\n    return \"\";\n  },\n  nodeToString(node) {\n    if (typeof node === \"string\") return node;\n    if (isObject(node) && hasProp(node, \"label\")) return node.label;\n    return fallback2.nodeToValue(node);\n  },\n  isNodeDisabled(node) {\n    if (isObject(node) && hasProp(node, \"disabled\")) return !!node.disabled;\n    return false;\n  },\n  nodeToChildren(node) {\n    return node.children;\n  }\n};\n\nexport { GridCollection, ListCollection, TreeCollection, filePathToTree, flattenedToTree };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}