{"ast":null,"code":"import { NumberFormatter as $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 } from \"./NumberFormatter.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec', 'deva', 'beng'];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n  /**\n  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n  */\n  parse(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n  /**\n  * Returns whether the given string could potentially be a valid number. This should be used to\n  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n  * of the minus/plus sign characters can be checked.\n  */\n  isValidPartialNumber(value, minValue, maxValue) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n  /**\n  * Returns a numbering system for which the given string is valid in the current locale.\n  * If no numbering system could be detected, the default numbering system for the current\n  * locale is returned.\n  */\n  getNumberingSystem(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {\n      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n      if (parser.isValidPartialNumber(value)) return parser;\n    }\n  }\n  return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n  }\n  return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n  parse(value) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n    if (this.symbols.group)\n      // Remove group characters, and replace decimal points and numerals with ASCII values.\n      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '');\n    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, '.');\n    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, '-');\n    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\n    if (this.options.style === 'percent') {\n      // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\n      let isNegative = fullySanitizedValue.indexOf('-');\n      fullySanitizedValue = fullySanitizedValue.replace('-', '');\n      let index = fullySanitizedValue.indexOf('.');\n      if (index === -1) index = fullySanitizedValue.length;\n      fullySanitizedValue = fullySanitizedValue.replace('.', '');\n      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;else if (index - 2 === -2) fullySanitizedValue = '0.00';else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\n      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;\n    }\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) return NaN;\n    if (this.options.style === 'percent') {\n      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\n      // extra step for rounding percents to what our formatter would output\n      let options = {\n        ...this.options,\n        style: 'decimal',\n        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),\n        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)\n      };\n      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));\n    }\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n    return newValue;\n  }\n  sanitize(value) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, '');\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    if (this.symbols.minusSign) value = value.replace('-', this.symbols.minusSign);\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === 'arab') {\n      if (this.symbols.decimal) {\n        value = value.replace(',', this.symbols.decimal);\n        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      }\n      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);\n    }\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === 'fr-FR') value = $6c7bd7858deea686$var$replaceAll(value, '.', String.fromCharCode(8239));\n    return value;\n  }\n  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n    value = this.sanitize(value);\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n    // Numbers cannot start with a group separator\n    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;\n    // Numbers that can't have any decimal values fail if a decimal character is typed\n    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;\n    // Remove numerals, groups, and decimals\n    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '');\n    value = value.replace(this.symbols.numeral, '');\n    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, '');\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);\n    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\n    if (this.options.style === 'percent' && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');\n  }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];\nfunction $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {\n  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;\n  // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\n  let symbolFormatter = new Intl.NumberFormat(locale, {\n    ...intlOptions,\n    // Resets so we get the full range of symbols\n    minimumSignificantDigits: 1,\n    maximumSignificantDigits: 21,\n    roundingIncrement: 1,\n    roundingPriority: 'auto',\n    roundingMode: 'halfExpand'\n  });\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = symbolFormatter.formatToParts(-10000.111);\n  let posAllParts = symbolFormatter.formatToParts(10000.111);\n  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map(n => symbolFormatter.formatToParts(n));\n  var _allParts_find_value;\n  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find(p => p.type === 'minusSign')) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : '-';\n  let plusSign = (_posAllParts_find = posAllParts.find(p => p.type === 'plusSign')) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';\n  // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\n  // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\n  let decimalParts = new Intl.NumberFormat(locale, {\n    ...intlOptions,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).formatToParts(0.001);\n  let decimal = (_decimalParts_find = decimalParts.find(p => p.type === 'decimal')) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;\n  let group = (_allParts_find1 = allParts.find(p => p.type === 'group')) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? new RegExp('[\\\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {\n    useGrouping: false\n  }).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n  let index = d => String(indexes.get(d));\n  return {\n    minusSign: minusSign,\n    plusSign: plusSign,\n    decimal: decimal,\n    group: group,\n    literals: literals,\n    numeral: numeral,\n    index: index\n  };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n  if (str.replaceAll) return str.replaceAll(find, replace);\n  return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nexport { $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser };","map":{"version":3,"names":["$6c7bd7858deea686$var$CURRENCY_SIGN_REGEX","RegExp","$6c7bd7858deea686$var$NUMBERING_SYSTEMS","$6c7bd7858deea686$export$cd11ab140839f11d","parse","value","$6c7bd7858deea686$var$getNumberParserImpl","locale","options","isValidPartialNumber","minValue","maxValue","getNumberingSystem","numberingSystem","constructor","$6c7bd7858deea686$var$numberParserCache","Map","defaultParser","$6c7bd7858deea686$var$getCachedNumberParser","includes","parser","cacheKey","Object","entries","sort","a","b","join","get","$6c7bd7858deea686$var$NumberParserImpl","set","fullySanitizedValue","sanitize","symbols","group","$6c7bd7858deea686$var$replaceAll","decimal","replace","minusSign","numeral","index","style","isNegative","indexOf","length","slice","newValue","NaN","isNaN","_this_options_minimumFractionDigits","_this_options_maximumFractionDigits","minimumFractionDigits","Math","min","maximumFractionDigits","$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5","format","currencySign","test","literals","String","fromCharCode","Infinity","startsWith","plusSign","formatter","Intl","NumberFormat","resolvedOptions","$6c7bd7858deea686$var$getSymbols","console","warn","$6c7bd7858deea686$var$nonLiteralParts","Set","$6c7bd7858deea686$var$pluralNumbers","intlOptions","originalOptions","_allParts_find","_posAllParts_find","_decimalParts_find","_allParts_find1","symbolFormatter","minimumSignificantDigits","maximumSignificantDigits","roundingIncrement","roundingPriority","roundingMode","allParts","formatToParts","posAllParts","pluralParts","map","n","_allParts_find_value","find","p","type","signDisplay","decimalParts","allPartsLiterals","filter","has","$6c7bd7858deea686$var$escapeRegex","pluralPartsLiterals","flatMap","sortedLiterals","numerals","useGrouping","reverse","indexes","d","i","str","replaceAll","split","string"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@internationalized/number/dist/packages/@internationalized/number/src/NumberParser.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {NumberFormatter} from './NumberFormatter';\n\ninterface Symbols {\n  minusSign?: string,\n  plusSign?: string,\n  decimal?: string,\n  group?: string,\n  literals: RegExp,\n  numeral: RegExp,\n  index: (v: string) => string\n}\n\nconst CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst NUMBERING_SYSTEMS = ['latn', 'arab', 'hanidec', 'deva', 'beng'];\n\n/**\n * A NumberParser can be used to perform locale-aware parsing of numbers from Unicode strings,\n * as well as validation of partial user input. It automatically detects the numbering system\n * used in the input, and supports parsing decimals, percentages, currency values, and units\n * according to the locale.\n */\nexport class NumberParser {\n  private locale: string;\n  private options: Intl.NumberFormatOptions;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n\n  /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */\n  parse(value: string): number {\n    return getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n\n  /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */\n  isValidPartialNumber(value: string, minValue?: number, maxValue?: number): boolean {\n    return getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n\n  /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */\n  getNumberingSystem(value: string): string {\n    return getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n}\n\nconst numberParserCache = new Map<string, NumberParserImpl>();\nfunction getNumberParserImpl(locale: string, options: Intl.NumberFormatOptions, value: string) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = getCachedNumberParser(locale, options);\n\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of NUMBERING_SYSTEMS) {\n      if (numberingSystem !== defaultParser.options.numberingSystem) {\n        let parser = getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n        if (parser.isValidPartialNumber(value)) {\n          return parser;\n        }\n      }\n    }\n  }\n\n  return defaultParser;\n}\n\nfunction getCachedNumberParser(locale: string, options: Intl.NumberFormatOptions) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');\n  let parser = numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new NumberParserImpl(locale, options);\n    numberParserCache.set(cacheKey, parser);\n  }\n\n  return parser;\n}\n\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass NumberParserImpl {\n  formatter: Intl.NumberFormat;\n  options: Intl.ResolvedNumberFormatOptions;\n  symbols: Symbols;\n  locale: string;\n\n  constructor(locale: string, options: Intl.NumberFormatOptions = {}) {\n    this.locale = locale;\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = getSymbols(locale, this.formatter, this.options, options);\n    if (this.options.style === 'percent' && ((this.options.minimumFractionDigits ?? 0) > 18 || (this.options.maximumFractionDigits ?? 0) > 18)) {\n      console.warn('NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.');\n    }\n  }\n\n  parse(value: string) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n\n    if (this.symbols.group) {\n      // Remove group characters, and replace decimal points and numerals with ASCII values.\n      fullySanitizedValue = replaceAll(fullySanitizedValue, this.symbols.group, '');\n    }\n    if (this.symbols.decimal) {\n      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal!, '.');\n    }\n    if (this.symbols.minusSign) {\n      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign!, '-');\n    }\n    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\n\n    if (this.options.style === 'percent') {\n      // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\n      let isNegative = fullySanitizedValue.indexOf('-');\n      fullySanitizedValue = fullySanitizedValue.replace('-', '');\n      let index = fullySanitizedValue.indexOf('.');\n      if (index === -1) {\n        index = fullySanitizedValue.length;\n      }\n      fullySanitizedValue = fullySanitizedValue.replace('.', '');\n      if (index - 2 === 0) {\n        fullySanitizedValue = `0.${fullySanitizedValue}`;\n      } else if (index - 2 === -1) {\n        fullySanitizedValue = `0.0${fullySanitizedValue}`;\n      } else if (index - 2 === -2) {\n        fullySanitizedValue = '0.00';\n      } else {\n        fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\n      }\n      if (isNegative > -1) {\n        fullySanitizedValue = `-${fullySanitizedValue}`;\n      }\n    }\n\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) {\n      return NaN;\n    }\n\n    if (this.options.style === 'percent') {\n      // extra step for rounding percents to what our formatter would output\n      let options = {\n        ...this.options,\n        style: 'decimal' as const,\n        minimumFractionDigits: Math.min((this.options.minimumFractionDigits ?? 0) + 2, 20),\n        maximumFractionDigits: Math.min((this.options.maximumFractionDigits ?? 0) + 2, 20)\n      };\n      return (new NumberParser(this.locale, options)).parse(new NumberFormatter(this.locale, options).format(newValue));\n    }\n\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === 'accounting' && CURRENCY_SIGN_REGEX.test(value)) {\n      newValue = -1 * newValue;\n    }\n\n    return newValue;\n  }\n\n  sanitize(value: string) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, '');\n\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    if (this.symbols.minusSign) {\n      value = value.replace('-', this.symbols.minusSign);\n    }\n\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === 'arab') {\n      if (this.symbols.decimal) {\n        value = value.replace(',', this.symbols.decimal);\n        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      }\n      if (this.symbols.group) {\n        value = replaceAll(value, '.', this.symbols.group);\n      }\n    }\n\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === 'fr-FR') {\n      value = replaceAll(value, '.', String.fromCharCode(8239));\n    }\n\n    return value;\n  }\n\n  isValidPartialNumber(value: string, minValue: number = -Infinity, maxValue: number = Infinity): boolean {\n    value = this.sanitize(value);\n\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) {\n      value = value.slice(this.symbols.minusSign.length);\n    } else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) {\n      value = value.slice(this.symbols.plusSign.length);\n    }\n\n    // Numbers cannot start with a group separator\n    if (this.symbols.group && value.startsWith(this.symbols.group)) {\n      return false;\n    }\n\n    // Numbers that can't have any decimal values fail if a decimal character is typed\n    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) {\n      return false;\n    }\n\n    // Remove numerals, groups, and decimals\n    if (this.symbols.group) {\n      value = replaceAll(value, this.symbols.group, '');\n    }\n    value = value.replace(this.symbols.numeral, '');\n    if (this.symbols.decimal) {\n      value = value.replace(this.symbols.decimal, '');\n    }\n\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n}\n\nconst nonLiteralParts = new Set(['decimal', 'fraction', 'integer', 'minusSign', 'plusSign', 'group']);\n\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst pluralNumbers = [\n  0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1\n];\n\nfunction getSymbols(locale: string, formatter: Intl.NumberFormat, intlOptions: Intl.ResolvedNumberFormatOptions, originalOptions: Intl.NumberFormatOptions): Symbols {\n  // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\n  let symbolFormatter = new Intl.NumberFormat(locale, {...intlOptions,\n    // Resets so we get the full range of symbols\n    minimumSignificantDigits: 1,\n    maximumSignificantDigits: 21,\n    roundingIncrement: 1,\n    roundingPriority: 'auto',\n    roundingMode: 'halfExpand'\n  });\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = symbolFormatter.formatToParts(-10000.111);\n  let posAllParts = symbolFormatter.formatToParts(10000.111);\n  let pluralParts = pluralNumbers.map(n => symbolFormatter.formatToParts(n));\n\n  let minusSign = allParts.find(p => p.type === 'minusSign')?.value ?? '-';\n  let plusSign = posAllParts.find(p => p.type === 'plusSign')?.value;\n\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  if (!plusSign && (originalOptions?.signDisplay === 'exceptZero' || originalOptions?.signDisplay === 'always')) {\n    plusSign = '+';\n  }\n\n  // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\n  // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\n  let decimalParts = new Intl.NumberFormat(locale, {...intlOptions, minimumFractionDigits: 2, maximumFractionDigits: 2}).formatToParts(0.001);\n\n  let decimal = decimalParts.find(p => p.type === 'decimal')?.value;\n  let group = allParts.find(p => p.type === 'group')?.value;\n\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !nonLiteralParts.has(p.type)).map(p => escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n\n  let literals = sortedLiterals.length === 0 ?\n      new RegExp('[\\\\p{White_Space}]', 'gu') :\n      new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {useGrouping: false}).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n  let index = d => String(indexes.get(d));\n\n  return {minusSign, plusSign, decimal, group, literals, numeral, index};\n}\n\nfunction replaceAll(str: string, find: string, replace: string) {\n  if (str.replaceAll) {\n    return str.replaceAll(find, replace);\n  }\n\n  return str.split(find).join(replace);\n}\n\nfunction escapeRegex(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}