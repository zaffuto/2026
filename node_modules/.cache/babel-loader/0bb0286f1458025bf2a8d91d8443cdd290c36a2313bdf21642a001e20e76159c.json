{"ast":null,"code":"import { getDocument, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, raf, getEventTarget, isDocument, isFocusable, getActiveElement } from '@zag-js/dom-query';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", event => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const {\n              tabbableNodes\n            } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex(node => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some(g => g.tabbableNodes.some(n => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({\n          returnFocus: this.config.returnFocusOnDeactivate\n        });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", event => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", event => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({\n          event,\n          isBackward\n        });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", event => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver(mutations => {\n        const isFocusedNodeRemoved = mutations.some(mutation => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some(node => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map(container => {\n          this._mutationObserver?.observe(container, {\n            subtree: true,\n            childList: true\n          });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", {\n        hasFallback: true\n      });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        if (this.findContainerIndex(this.doc.activeElement) >= 0) {\n          node = this.doc.activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", node => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({\n        preventScroll: !!this.config.preventScroll\n      });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", deactivateOptions => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", pauseOptions => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", unpauseOptions => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", containerElements => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", previousActiveElement => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] :\n      // @ts-expect-error\n      this.config[configOptionName || optionName];\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, {\n      hasFallback = false,\n      params = []\n    } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", opts => {\n      const {\n        event,\n        isBackward = false\n      } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(({\n            firstTabbableNode\n          }) => target === firstTabbableNode);\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(({\n            lastTabbableNode\n          }) => target === lastTabbableNode);\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(({\n      container,\n      tabbableNodes\n    }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find(node => node === element));\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map(container => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find(node => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find(node => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find(node => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(el => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(el => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter(group => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\"Your focus-trap must have at least one container with at least one tabbable node in it at all times\");\n    }\n    if (this.state.containerGroups.find(g => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(addDomEvent(this.doc, \"focusin\", this.handleFocus, true), addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"click\", this.handleClick, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleTabKey, {\n      capture: true,\n      passive: false\n    }), addDomEvent(this.doc, \"keydown\", this.handleEscapeKey));\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach(cleanup => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = event => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = event => !event.isComposing && event.key === \"Escape\";\nvar delay = fn => setTimeout(fn, 0);\nvar isSelectableInput = node => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {}\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\nexport { FocusTrap, trapFocus };","map":{"version":3,"names":["getDocument","getTabbables","getFocusables","isTabbable","getTabIndex","addDomEvent","raf","getEventTarget","isDocument","isFocusable","getActiveElement","__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","activeFocusTraps","activateTrap","trapStack","trap","length","activeTrap","pause","trapIndex","indexOf","push","splice","deactivateTrap","unpause","sharedTrapStack","FocusTrap","constructor","elements","options","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","recentNavEvent","event","target","targetContained","findContainerIndex","state","stopImmediatePropagation","nextNode","navAcrossContainers","mruContainerIdx","tabbableNodes","mruTabIdx","findIndex","node","config","isKeyForward","some","g","n","findNextNavNode","isBackward","isKeyBackward","tryFocus","getInitialFocusNode","valueOrHandler","clickOutsideDeactivates","deactivate","returnFocus","returnFocusOnDeactivate","allowOutsideClick","preventDefault","destinationNode","isTabEvent","isEscapeEvent","escapeDeactivates","win","doc","defaultView","window","_mutationObserver","MutationObserver","mutations","isFocusedNodeRemoved","mutation","removedNodes","Array","from","disconnect","map","container","observe","subtree","childList","getNodeForOption","hasFallback","activeElement","firstTabbableGroup","firstTabbableNode","Error","isConnected","focus","preventScroll","isSelectableInput","select","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","removeListeners","updateObservedNodes","getOption","finishDeactivation","delay","returnFocusNode","getReturnFocusNode","then","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","updateTabbableNodes","addListeners","containerElements","isArray","filter","Boolean","previousActiveElement","params","configOverrideOptions","optionName","configOptionName","optionValue","querySelector","err","message","opts","containerIndex","containerGroup","lastTabbableNode","startOfGroupIndex","nextTabbableNode","destinationGroupIndex","destinationGroup","lastDomTabbableNode","lastOfGroupIndex","firstDomTabbableNode","delayInitialFocus","e","shiftKey","document","updateContainerElements","setupMutationObserver","element","composedPath","contains","includes","find","focusableNodes","slice","reverse","posTabIndexesFound","forward","nodeIdx","el","group","listenerCleanups","handleFocus","handlePointerDown","capture","passive","handleClick","handleTabKey","handleEscapeKey","forEach","cleanup","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","concat","isComposing","fn","setTimeout","localName","trapFocus","contentEl","fallbackFocus","destroy"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@zag-js/focus-trap/dist/index.mjs"],"sourcesContent":["import { getDocument, getTabbables, getFocusables, isTabbable, getTabIndex, addDomEvent, raf, getEventTarget, isDocument, isFocusable, getActiveElement } from '@zag-js/dom-query';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = getEventTarget(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || isDocument(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = getEventTarget(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, { subtree: true, childList: true });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !isFocusable(node)) {\n        if (this.findContainerIndex(this.doc.activeElement) >= 0) {\n          node = this.doc.activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === getActiveElement(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || getEventTarget(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || getDocument(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)\n    );\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = getTabbables(container);\n      const focusableNodes = getFocusables(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      addDomEvent(this.doc, \"focusin\", this.handleFocus, true),\n      addDomEvent(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      addDomEvent(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = raf(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: getDocument(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\nexport { FocusTrap, trapFocus };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}