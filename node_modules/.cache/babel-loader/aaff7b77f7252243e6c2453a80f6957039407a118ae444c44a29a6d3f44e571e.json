{"ast":null,"code":"\"use strict\";\n\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const {\n      prefix,\n      allTokens,\n      formatCssVar,\n      formatTokenName,\n      registerToken\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"spacing\");\n    tokens.forEach(token => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */new Set([\"spacing\", \"sizes\", \"borderWidths\", \"fontSizes\", \"radii\"]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter(token => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach(token => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const {\n      allTokens,\n      registerToken,\n      formatTokenName\n    } = dictionary;\n    const tokens = allTokens.filter(({\n      extensions\n    }) => extensions.category === \"colors\");\n    const keys = /* @__PURE__ */new Map();\n    const colorPalettes = /* @__PURE__ */new Map();\n    tokens.forEach(token => {\n      const {\n        colorPalette\n      } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach(keyPath => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach(colorPaletteRoot => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach(segments => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(token => token.value !== \"\");\n  }\n};\nconst tokenMiddlewares = [addNegativeTokens, addVirtualPalette, addPixelUnit, removeEmptyTokens];\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };","map":{"version":3,"names":["isString","calc","toPx","addNegativeTokens","enforce","transform","dictionary","prefix","allTokens","formatCssVar","formatTokenName","registerToken","tokens","filter","extensions","category","forEach","token","originalPath","path","slice","originalVar","value","nextToken","structuredClone","Object","assign","negative","prop","negate","ref","lastPath","length","name","units","Set","addPixelUnit","has","pixelValue","addVirtualPalette","keys","Map","colorPalettes","colorPalette","keyPath","set","roots","colorPaletteRoot","colorPaletteList","get","push","default","Boolean","concat","segments","originalValue","condition","virtual","removeEmptyTokens","tokenMiddlewares"],"sources":["/Users/macbook/developer/2025/2026/node_modules/@chakra-ui/react/dist/esm/styled-system/token-middleware.js"],"sourcesContent":["\"use strict\";\nimport { isString } from '../utils/is.js';\nimport { calc } from './calc.js';\nimport { toPx } from './unit-conversion.js';\n\nconst addNegativeTokens = {\n  enforce: \"pre\",\n  transform(dictionary) {\n    const { prefix, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"spacing\"\n    );\n    tokens.forEach((token) => {\n      const originalPath = token.path.slice();\n      const originalVar = formatCssVar(originalPath, prefix);\n      if (isString(token.value) && token.value === \"0rem\") {\n        return;\n      }\n      const nextToken = structuredClone(token);\n      Object.assign(nextToken.extensions, {\n        negative: true,\n        prop: `-${token.extensions.prop}`,\n        originalPath\n      });\n      nextToken.value = calc.negate(originalVar.ref);\n      const lastPath = nextToken.path[nextToken.path.length - 1];\n      if (lastPath != null) {\n        nextToken.path[nextToken.path.length - 1] = `-${lastPath}`;\n      }\n      if (nextToken.path) {\n        nextToken.name = formatTokenName(nextToken.path);\n      }\n      registerToken(nextToken);\n    });\n  }\n};\nconst units = /* @__PURE__ */ new Set([\n  \"spacing\",\n  \"sizes\",\n  \"borderWidths\",\n  \"fontSizes\",\n  \"radii\"\n]);\nconst addPixelUnit = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const tokens = dictionary.allTokens.filter((token) => {\n      return units.has(token.extensions.category) && !token.extensions.negative;\n    });\n    tokens.forEach((token) => {\n      Object.assign(token.extensions, {\n        pixelValue: toPx(token.value)\n      });\n    });\n  }\n};\nconst addVirtualPalette = {\n  enforce: \"post\",\n  transform(dictionary) {\n    const { allTokens, registerToken, formatTokenName } = dictionary;\n    const tokens = allTokens.filter(\n      ({ extensions }) => extensions.category === \"colors\"\n    );\n    const keys = /* @__PURE__ */ new Map();\n    const colorPalettes = /* @__PURE__ */ new Map();\n    tokens.forEach((token) => {\n      const { colorPalette } = token.extensions;\n      if (!colorPalette) return;\n      colorPalette.keys.forEach((keyPath) => {\n        keys.set(formatTokenName(keyPath), keyPath);\n      });\n      colorPalette.roots.forEach((colorPaletteRoot) => {\n        const name = formatTokenName(colorPaletteRoot);\n        const colorPaletteList = colorPalettes.get(name) || [];\n        colorPaletteList.push(token);\n        colorPalettes.set(name, colorPaletteList);\n        if (token.extensions.default && colorPaletteRoot.length === 1) {\n          const keyPath = colorPalette.keys[0]?.filter(Boolean);\n          if (!keyPath.length) return;\n          const path = colorPaletteRoot.concat(keyPath);\n          keys.set(formatTokenName(path), []);\n        }\n      });\n    });\n    keys.forEach((segments) => {\n      const path = [\"colors\", \"colorPalette\", ...segments].filter(Boolean);\n      const name = formatTokenName(path);\n      const prop = formatTokenName(path.slice(1));\n      const token = {\n        name,\n        value: name,\n        originalValue: name,\n        path,\n        extensions: {\n          condition: \"base\",\n          originalPath: path,\n          category: \"colors\",\n          prop,\n          virtual: true\n        }\n      };\n      registerToken(token, \"pre\");\n    });\n  }\n};\nconst removeEmptyTokens = {\n  enforce: \"post\",\n  transform(dictionary) {\n    dictionary.allTokens = dictionary.allTokens.filter(\n      (token) => token.value !== \"\"\n    );\n  }\n};\nconst tokenMiddlewares = [\n  addNegativeTokens,\n  addVirtualPalette,\n  addPixelUnit,\n  removeEmptyTokens\n];\n\nexport { addNegativeTokens, addPixelUnit, addVirtualPalette, removeEmptyTokens, tokenMiddlewares };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}